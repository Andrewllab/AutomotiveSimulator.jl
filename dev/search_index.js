var documenterSearchIndex = {"docs":
[{"location":"Vec/#Vec-1","page":"Vec","title":"Vec","text":"","category":"section"},{"location":"Vec/#","page":"Vec","title":"Vec","text":"Vec is a submodule of AutomotiveSimulator that provides several vector types, named after their groups. All types are immutable and are subtypes of 'StaticArrays'' FieldVector, so they can be indexed and used as vectors in many contexts.","category":"page"},{"location":"Vec/#","page":"Vec","title":"Vec","text":"VecE2 provides an (x,y) type of the Euclidean-2 group.\nVecE3 provides an (x,y,z) type of the Euclidean-3 group.\nVecSE2 provides an (x,y,theta) type of the special-Euclidean 2 group.","category":"page"},{"location":"Vec/#","page":"Vec","title":"Vec","text":"v = VecE2(0, 1)\nv = VecSE2(0,1,0.5)\nv = VecE3(0, 1, 2)","category":"page"},{"location":"Vec/#","page":"Vec","title":"Vec","text":"Additional geometry types include Quat for quaternions, Line, LineSegment, and Projectile.","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/straight_roadway.jl\"","category":"page"},{"location":"tutorials/straight_roadway/#Driving-on-a-Straight-Roadway-1","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"","category":"section"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: )","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"This example demonstrates a simple, one-dimensional driving simulation in which cars drive along a straight roadway. The vehicles are represented using the Entity type with the followin attributes:","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"state - VehicleState, containing the vehicle position and speed\ndef - VehicleDef, containing length, width, and class\nid - Int, a unique label for each vehicle`","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"A driving situation with different vehicles at a given time is referred to as a scene. It is represented by the Scene object. A Scene can be thought of as a vector of vehicles. However, in addition to simple vectors it allows to query vehicles by ID using the get_by_id function. We use a straight roadway with 1 lane as the environment.","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using AutomotiveSimulator\nusing AutomotiveVisualization # for rendering\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\n\nroadway = gen_straight_roadway(1, 2000.0)  # 200m long straight roadway with 1 lane\nscene = Scene([\n    Entity(VehicleState(VecSE2(10.0,0.0,0.0), roadway, 8.0), VehicleDef(), 1),\n    Entity(VehicleState(VecSE2(50.0,0.0,0.0), roadway, 12.5), VehicleDef(), 2),\n    Entity(VehicleState(VecSE2(150.0,0.0,0.0), roadway, 6.0), VehicleDef(), 3),\n])\n\nveh_1 = get_by_id(scene, 1) # note that the order of the vehicles in the scene does not necessarily match the id\n\ncamera = StaticCamera(position=VecE2(100.0,0.0), zoom=4.75, canvas_height=100)\nsnapshot = render([roadway, scene], camera=camera)\nwrite(\"straight_roadway.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three cars on road)","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"In this call to the render function, we use the default rendering behavior for entities. More advanced examples will show how the rendering of entities can be customized.","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"We can add an overlay that displays the car id:","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"idoverlay = IDOverlay(scene=scene, color=colorant\"black\", font_size=20, y_off=1.)\nsnapshot = render([roadway, scene, idoverlay], camera=camera)\nwrite(\"straight_roadway_with_id.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three cars with id)","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"To run a simulation we need driving models that produce actions. For this we will use LaneFollowingDrivers that produce LaneFollowingAccels. For this demo, we will give each car a different model.","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"models = Dict{Int, LaneFollowingDriver}(\n    1 => StaticLaneFollowingDriver(0.0), # always produce zero acceleration\n    2 => IntelligentDriverModel(v_des=12.0), # default IDM with a desired speed of 12 m/s\n    3 => PrincetonDriver(v_des = 10.0), # default Princeton driver with a desired speed of 10m/s\n)\n\nnticks = 100\ntimestep = 0.1\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"We can visualize the simulation as a sequence of images, for example using the Reel package","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using Reel\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    idoverlay.scene = scenes[i]\n    renderables = [roadway, scenes[i], idoverlay]\n    render(renderables, camera=camera)\nend\nwrite(\"straight_roadway_animated.gif\", animation) # hide\nnothing # hide","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"(Image: three vehicles animated)","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"In order to inspect the simulation interactively, we can use the Interact package","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"using Interact\nusing Blink\nusing ElectronDisplay\n#md\nw = Window()\nviz = @manipulate for step in 1 : length(scenes)\n    renderables = [roadway, scenes[step], IDOverlay(scene=scenes[step], roadway=roadway)]\n    render(renderables, camera=camera)\nend\nbody!(w, viz)","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"","category":"page"},{"location":"tutorials/straight_roadway/#","page":"Driving on a Straight Roadway","title":"Driving on a Straight Roadway","text":"This page was generated using Literate.jl.","category":"page"},{"location":"feature_extraction/#Feature-Extraction-1","page":"Feature Extraction","title":"Feature Extraction","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"AutomotiveSimulator.jl provides useful functions to extract information from a scene.","category":"page"},{"location":"feature_extraction/#Feature-Extraction-Pipeline-1","page":"Feature Extraction","title":"Feature Extraction Pipeline","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"The function extract_features can be used to extract information from a list of scenes. It takes as input a vector of scenes (which could be the output of simulate), as well as a list of feature functions to use. The output is a dictionary of DataFrame from DataFrames.jl.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    extract_features","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.extract_features","page":"Feature Extraction","title":"AutomotiveSimulator.extract_features","text":"extract_features(features, roadway::Roadway, scenes::Vector{<:Scene}, ids::Vector{I}) where I\n\nExtract information from a list of scenes. It returns a dictionary of DataFrame objects. \n\nInputs\n\nfeatures: a tuple of feature functions. The feature types supported are EntityFeature, SceneFeature and TemporalFeature. Check the documentation for the list of available feature functions, and how to implement you own feature function.\nroadway::Roadway : the roadway associated to the scenes.\nscenes::Vector{<:Scene} : the simulation data from which we wish to extract information from. Each scene in the vector corresponds to one time step.\nids::Vector{I}: a list of entity IDs for which we want to extract the information. \n\nOutput\n\nA dictionary mapping IDs to DataFrame objects. For a given ID, the DataFrame's columns correspond to the name of the input feature functions.  The row correspond to the feature value for each scene (time history).\n\nExample:\n\nroadway = gen_straight_roadway(4, 100.0) \n\nscene_0 = Scene([\n            Entity(VehicleState(VecSE2( 0.0,0.0,0.0), roadway, 10.0), VehicleDef(AgentClass.CAR, 5.0, 2.0), 1),\n            Entity(VehicleState(VecSE2(10.0,0.0,0.0), roadway, 10.0), VehicleDef(AgentClass.CAR, 5.0, 2.0), 2),\n        ])\n\nscene_1 = Scene([\n            Entity(VehicleState(VecSE2( 10.0,0.0,0.0), roadway, 10.0), VehicleDef(AgentClass.CAR, 5.0, 2.0), 1),\n            Entity(VehicleState(VecSE2(20.0,0.0,0.0), roadway, 10.0), VehicleDef(AgentClass.CAR, 5.0, 2.0), 2),\n        ])\n\ndfs = extract_features((posgx, iscolliding), roadway, [scene_0, scene_1], [1,2])\n\ndfs[1].posgx # history of global x position for vehicle of ID 1\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#Finding-neighbors-1","page":"Feature Extraction","title":"Finding neighbors","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"Finding neighbors of an entity is a common query and can be done using the find_neighbor function.  This function allows to find the neighbor of an entity within a scene using a forward search method.  The search algorithm moves longitudinally along a given lane and its successors (according to the given road topology).  Once it finds a car it stops searching and return the results as a NeighborLongitudinalResult","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    NeighborLongitudinalResult","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.NeighborLongitudinalResult","page":"Feature Extraction","title":"AutomotiveSimulator.NeighborLongitudinalResult","text":"NeighborLongitudinalResult\n\nA structure to retrieve information about a neihbor in the longitudinal direction i.e. rear and front neighbors on the same lane. If the neighbor index is equal to nothing it means there is no neighbor.\n\nFields\n\nind::Union{Nothing, Int64} index of the neighbor in the scene\nΔs::Float64 positive distance along the lane between vehicles positions\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"The find_neighbor function accepts different keyword argument to search front or rear neighbors, or neighbors on different lanes.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    find_neighbor","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.find_neighbor","page":"Feature Extraction","title":"AutomotiveSimulator.find_neighbor","text":"find_neighbor(scene::Scene, roadway::Roawday, ego::Entity; kwargs...)\n\nSearch through lanes and road segments to find a neighbor of ego in the scene. \n\nArguments\n\nscene::Scene the scene containing all the entities\nroadway::Roadway the road topology on which entities are driving \nego::Entity the entity that we want to compute the neighbor of.\n\nKeyword arguments\n\nlane::Union{Nothing, Lane} the lane on which to search the neighbor, if different from the ego vehicle current lane, it uses the projection of the ego vehicle on the given lane as a reference point. If nothing, returns nothing.\nrear::Bool = false set to true to search for rear neighbor, search forward neighbor by default \nmax_distance::Float64 = 250.0 stop searching after this distance is reached, if the neighbor is further than max_distance, returns nothing\ntargetpoint_ego::VehicleTargetPoint the point on the ego vehicle used for distance calculation, see VehicleTargetPoint for more info\ntargetpoint_neighbor::VehicleTargetPoint the point on the neighbor vehicle used for distance calculation, see VehicleTargetPoint for more info\nids_to_ignore::Union{Nothing, Set{I}} = nothing a list of entity ids to ignore for the search, ego is always ignored.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"When computing the distance to a neighbor, one might want to choose different reference points on the vehicle (center to center, bumper to bumper, etc...). AutomotiveSimulator provides the VehicleTargetPoint types to do so.  One can choose among three possible instances to use the front, center, or rear point of a vehicle to compute the distance to the neighbor.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    VehicleTargetPoint\n    VehicleTargetPointCenter\n    VehicleTargetPointFront\n    VehicleTargetPointRear","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.VehicleTargetPoint","page":"Feature Extraction","title":"AutomotiveSimulator.VehicleTargetPoint","text":"VehicleTargetPoint\n\nDefines a point on an entity that is used to measure distances.  The following target points are supported and are subtypes of VehicleTargetPoint: \n\nVehicleTargetPointFront\nVehicleTargetPointCenter\nVehicleTargetPointRear\n\nThe method targetpoint_delta(::VehicleTargetPoint, ::Entity) can be used to  compute the delta in the longitudinal direction to add when considering a specific target point.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#AutomotiveSimulator.VehicleTargetPointCenter","page":"Feature Extraction","title":"AutomotiveSimulator.VehicleTargetPointCenter","text":"VehicleTargetPointCenter <: VehicleTargetPoint\n\nSet the target point at the center of the entity.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#AutomotiveSimulator.VehicleTargetPointFront","page":"Feature Extraction","title":"AutomotiveSimulator.VehicleTargetPointFront","text":"VehicleTargetPointFront <: VehicleTargetPoint\n\nSet the target point at the front (and center) of the entity.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#AutomotiveSimulator.VehicleTargetPointRear","page":"Feature Extraction","title":"AutomotiveSimulator.VehicleTargetPointRear","text":"VehicleTargetPointFront <: VehicleTargetPoint\n\nSet the target point at the front (and center) of the entity.\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"To get the relative position of two vehicles in the Frenet frame, the get_frenet_relative_position can be used.  It stores the result in a FrenetRelativePosition object.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    get_frenet_relative_position\n    FrenetRelativePosition","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.get_frenet_relative_position","page":"Feature Extraction","title":"AutomotiveSimulator.get_frenet_relative_position","text":"get_frenet_relative_position(veh_fore::Entity, veh_rear::Entity, roadway::Roadway)\n\nreturn the Frenet relative position between the two vehicles. It projects the position of the first vehicle onto the lane of the second vehicle. The result is stored as a FrenetRelativePosition.\n\nLower level:     getfrenetrelativeposition(posG::VecSE2{Float64}, roadind::RoadIndex, roadway::Roadway;         maxdistancefore::Float64 = 250.0, # max distance to search forward [m]         maxdistancerear::Float64 = 250.0, # max distance to search backward [m]         improvementthreshold::Float64 = 1e-4,     )\n\nProject the given point to the same lane as the given RoadIndex. This will return the projection of the point, along with the Δs along the lane from the RoadIndex. The returned type is a FrenetRelativePosition object.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.FrenetRelativePosition","page":"Feature Extraction","title":"AutomotiveSimulator.FrenetRelativePosition","text":"FrenetRelativePosition\n\nContains information about the projection of a point on a lane. See get_frenet_relative_position.\n\nFields\n\norigin::RoadIndex original roadindex used for the projection, contains the target lane ID.\ntarget::RoadIndex roadindex reached after projection\nΔs::Float64 longitudinal distance to the original roadindex \nt::Float64 lateral distance to the original roadindex in the frame of the target lane\nϕ::Float64 angle with the original roadindex in the frame of the target lane\n\n\n\n\n\n","category":"type"},{"location":"feature_extraction/#Implementing-Your-Own-Feature-Function-1","page":"Feature Extraction","title":"Implementing Your Own Feature Function","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"In AutomotiveSimulator, features are functions. The current interface supports three methods: ","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"myfeature(::Roadway, ::Entity) \nmyfeature(::Roadway, ::Scene, ::Entity)\nmyfeature(::Roadway, ::Vector{<:Scene}, ::Entity) ","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"For each of those methods, the last argument correspond to the entity with one of the ID given to the top level extract_features function.  Creating a new feature consists of implementing one of those methods for your feature function.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"As an example, let's define a feature function that returns the distance to the rear neighbor. Such feature will use the second method since it needs information about the whole scene to find the neighbor. If there are not rear neighbor then the function will return missing. DataFrame are designed to handled missing values so it should not be an issue.","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"function distance_to_rear_neighbor(roadway::Roadway, scene::Scene, ego::Entity)\n    neighbor = find_neighbor(scene, roadway, veh, rear=true)\n    if neighbor.ind === nothing \n        return missing \n    else \n        return neighbor.Δs\n    end\nend","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"Now you can use your feature function in extract features, the name of the function is used to name the column of the dataframe: ","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"    dfs = extract_features((distance_to_rear_neighbor,), roadway, scenes, [1])\n    dfs[1].distance_to_rear_neighbor # contains history of distances to rear neighor","category":"page"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"!!!note      If the supported methods are limiting for your use case please open an issue or submit a PR.      It should be straightforward to extend the extract_features function to support other methods, as well as adding new feature trait.","category":"page"},{"location":"feature_extraction/#List-of-Available-Features-1","page":"Feature Extraction","title":"List of Available Features","text":"","category":"section"},{"location":"feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"  posgx\n  posgy\n  posgθ\n  posfs\n  posft\n  posfϕ\n  vel(roadway::Roadway, veh::Entity)\n  velfs\n  velft\n  velgx\n  velgy\n  time_to_crossing_right\n  time_to_crossing_left\n  estimated_time_to_lane_crossing\n  iswaiting\n  iscolliding\n  distance_to\n  acc\n  accfs\n  accft\n  jerk\n  jerkft\n  turn_rate_g\n  turn_rate_f\n  isbraking\n  isaccelerating\n  lane_width\n  markerdist_left\n  markerdist_right\n  road_edge_dist_left\n  road_edge_dist_right\n  lane_offset_left\n  lane_offset_right\n  n_lanes_left(roadway::Roadway, veh::Entity)\n  n_lanes_right(roadway::Roadway, veh::Entity)\n  has_lane_left\n  has_lane_right\n  lane_curvature\n  dist_to_front_neighbor\n  front_neighbor_speed\n  time_to_collision","category":"page"},{"location":"feature_extraction/#AutomotiveSimulator.posgx","page":"Feature Extraction","title":"AutomotiveSimulator.posgx","text":"posgx(roadway::Roadway, veh::Entity)\n\nreturns x position in the global frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.posgy","page":"Feature Extraction","title":"AutomotiveSimulator.posgy","text":"posgy(roadway::Roadway, veh::Entity)\n\nreturns y position in the global frame \n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.posgθ","page":"Feature Extraction","title":"AutomotiveSimulator.posgθ","text":"posgθ(roadway::Roadway, veh::Entity)\n\nreturns heading in the global frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.posfs","page":"Feature Extraction","title":"AutomotiveSimulator.posfs","text":"posfs(roadway::Roadway, veh::Entity)\n\nreturns longitudinal position in Frenet frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.posft","page":"Feature Extraction","title":"AutomotiveSimulator.posft","text":"posft(roadway::Roadway, veh::Entity)\n\nreturns lateral position in Frenet frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.posfϕ","page":"Feature Extraction","title":"AutomotiveSimulator.posfϕ","text":"posfϕ(roadway::Roadway, veh::Entity)\n\nreturns heading relative to centerline of the lane\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.vel-Tuple{Roadway,Entity}","page":"Feature Extraction","title":"AutomotiveSimulator.vel","text":"vel(roadway::Roadway, veh::Entity)\n\nreturns the velocity of veh\n\n\n\n\n\n","category":"method"},{"location":"feature_extraction/#AutomotiveSimulator.velfs","page":"Feature Extraction","title":"AutomotiveSimulator.velfs","text":"velfs(roadway::Roadway, veh::Entity)\n\nreturns the longitudinal velocity in the Frenet frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.velft","page":"Feature Extraction","title":"AutomotiveSimulator.velft","text":"velft(roadway::Roadway, veh::Entity)\n\nreturns the lateral velocity in the Frenet frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.velgx","page":"Feature Extraction","title":"AutomotiveSimulator.velgx","text":"velgx(roadway::Roadway, veh::Entity)\n\nreturns the velocity in the x direction of the global frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.velgy","page":"Feature Extraction","title":"AutomotiveSimulator.velgy","text":"velgy(roadway::Roadway, veh::Entity)\n\nreturns the velocity in the y direction of the global frame\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.time_to_crossing_right","page":"Feature Extraction","title":"AutomotiveSimulator.time_to_crossing_right","text":"time_to_crossing_right(roadway::Roadway, veh::Entity)\n\ntime before crossing the right lane marker assuming constant lateral speed.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.time_to_crossing_left","page":"Feature Extraction","title":"AutomotiveSimulator.time_to_crossing_left","text":"time_to_crossing_left(roadway::Roadway, veh::Entity)\n\ntime before crossing the left lane marker assuming constant lateral speed.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.estimated_time_to_lane_crossing","page":"Feature Extraction","title":"AutomotiveSimulator.estimated_time_to_lane_crossing","text":"estimated_time_to_lane_crossing(roadway::Roadway, veh::Entity)\n\nminimum of the time to crossing left and time to crossing right.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.iswaiting","page":"Feature Extraction","title":"AutomotiveSimulator.iswaiting","text":"iswaiting(roadway::Roadway, veh::Entity)\n\nreturns true if the vehicle is waiting (if the velocity is 0.0)\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.iscolliding","page":"Feature Extraction","title":"AutomotiveSimulator.iscolliding","text":"iscolliding(roadway::Roadway, scene::Scene, veh::Entity)\n\nreturns true if the vehicle is colliding with another vehicle in the scene.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.distance_to","page":"Feature Extraction","title":"AutomotiveSimulator.distance_to","text":"distance_to(egoid)\n\ngenerate a feature function distancetoegoid.\n\ndistance_to_$egoid(roadway, scene, veh) returns the distance between veh and the vehicle of id egoid in the scene.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.acc","page":"Feature Extraction","title":"AutomotiveSimulator.acc","text":"acc(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the history of acceleration of the entity of id vehid using finite differences on the velocity. The first element is missing.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.accfs","page":"Feature Extraction","title":"AutomotiveSimulator.accfs","text":"accfs(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the history of longitudinal acceleration in the Frenet frame of the entity of id vehid using finite differences on the velocity. The first element is missing.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.accft","page":"Feature Extraction","title":"AutomotiveSimulator.accft","text":"accft(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the history of lateral acceleration in the Frenet frame of the entity of id vehid using finite differences on the velocity. The first element is missing.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.jerk","page":"Feature Extraction","title":"AutomotiveSimulator.jerk","text":"jerk(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the jerk history of the entity of id vehid using finite differences on acceleration (which uses finite differences on velocity). The first two elements are missing. \n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.jerkft","page":"Feature Extraction","title":"AutomotiveSimulator.jerkft","text":"jerkft(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the lateral jerk history in the Frenet frame of the entity of id vehid using finite differences on acceleration (which uses finite differences on velocity). The first two elements are missing. \n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.turn_rate_g","page":"Feature Extraction","title":"AutomotiveSimulator.turn_rate_g","text":"turn_rate_g(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the turn rate history in the Frenet frame of the entity of id vehid using finite differences on global heading. The first element is missing. \n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.turn_rate_f","page":"Feature Extraction","title":"AutomotiveSimulator.turn_rate_f","text":"turn_rate_g(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nreturns the turn rate history in the Frenet frame of the entity of id vehid using finite differences on heading in the Frenet frame. The first element is missing. \n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.isbraking","page":"Feature Extraction","title":"AutomotiveSimulator.isbraking","text":"isbraking(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nhistory of braking events: true when the acceleration is negative. The first element is missing.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.isaccelerating","page":"Feature Extraction","title":"AutomotiveSimulator.isaccelerating","text":"isaccelerating(roadway::Roadway, scenes::Vector{<:Scene}, vehid)\n\nhistory of acceleration events: true when the acceleration is positive The first element is missing.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.lane_width","page":"Feature Extraction","title":"AutomotiveSimulator.lane_width","text":"lane_width(roadway::Roadway, veh::Entity)\n\nReturns the width of the lane where veh is.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.markerdist_left","page":"Feature Extraction","title":"AutomotiveSimulator.markerdist_left","text":"markerdist_left(roadway::Roadway, veh::Entity)\n\ndistance of veh to the left marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.markerdist_right","page":"Feature Extraction","title":"AutomotiveSimulator.markerdist_right","text":"markerdist_left(roadway::Roadway, veh::Entity)\n\ndistance of veh to the right marker of the lane\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.road_edge_dist_left","page":"Feature Extraction","title":"AutomotiveSimulator.road_edge_dist_left","text":"road_edge_dist_left(roadway::Roadway, veh::Entity)\n\nfeature function, extract the lateral distance to the left edge of the road\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.road_edge_dist_right","page":"Feature Extraction","title":"AutomotiveSimulator.road_edge_dist_right","text":"road_edge_dist_right(roadway::Roadway, veh::Entity)\n\nfeature function, extract the lateral distance to the right edge of the road\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.lane_offset_left","page":"Feature Extraction","title":"AutomotiveSimulator.lane_offset_left","text":"lane_offset_left(roadway::Roadway, veh::Entity)\n\nreturns the distance to the left lane border, if there are no left lane returns missing\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.lane_offset_right","page":"Feature Extraction","title":"AutomotiveSimulator.lane_offset_right","text":"lane_offset_right(roadway::Roadway, veh::Entity)\n\nreturns the distance to the right lane border, if there are no right lane returns missing\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.n_lanes_left-Tuple{Roadway,Entity}","page":"Feature Extraction","title":"AutomotiveSimulator.n_lanes_left","text":"n_lanes_left(roadway::Roadway, veh::Entity)\n\nreturn the numbers of lanes to the left of veh\n\n\n\n\n\n","category":"method"},{"location":"feature_extraction/#AutomotiveSimulator.n_lanes_right-Tuple{Roadway,Entity}","page":"Feature Extraction","title":"AutomotiveSimulator.n_lanes_right","text":"n_lanes_right(roadway::Roadway, veh::Entity)\n\nreturn the numbers of lanes to the right of veh\n\n\n\n\n\n","category":"method"},{"location":"feature_extraction/#AutomotiveSimulator.has_lane_left","page":"Feature Extraction","title":"AutomotiveSimulator.has_lane_left","text":"has_lane_left(roadway::Roadway, veh::Entity)\n\nReturn true if veh has a lane on its left.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.has_lane_right","page":"Feature Extraction","title":"AutomotiveSimulator.has_lane_right","text":"has_lane_right(roadway::Roadway, veh::Entity)\n\nReturn true if veh has a lane on its right.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.lane_curvature","page":"Feature Extraction","title":"AutomotiveSimulator.lane_curvature","text":"lane_curvature(roadway::Roadway, veh::Entity)\n\nReturn the curvature of the lane at veh's position. Return missing if the curvature is NaN\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.dist_to_front_neighbor","page":"Feature Extraction","title":"AutomotiveSimulator.dist_to_front_neighbor","text":"dist_to_front_neighbor(roadway::Roadway, scene::Scene, veh::Entity)\n\nFeature function to extract the longitudinal distance to the front neighbor (in the Frenet frame). Returns missing if there are no front neighbor.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.front_neighbor_speed","page":"Feature Extraction","title":"AutomotiveSimulator.front_neighbor_speed","text":"front_neighbor_speed(roadway::Roadway, scene::Scene, veh::Entity)\n\nFeature function to extract the velocity of the front neighbor. Returns missing if there are no front neighbor.\n\n\n\n\n\n","category":"function"},{"location":"feature_extraction/#AutomotiveSimulator.time_to_collision","page":"Feature Extraction","title":"AutomotiveSimulator.time_to_collision","text":"time_to_collision(roadway::Roadway, scene::Scene, veh::Entity)\n\nFeature function to extract the time to collision with the front neighbor. Returns missing if there are no front neighbor.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#Simulation-1","page":"Simulation","title":"Simulation","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"Simulations can be run using the simulate function.  A simulation updates the initial scene forward in time. Each simulation step consists of the following operations:","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"call the observe! function for each vehicle to update their driver model given the current scene \nsample an action from the driver model by calling rand on the driver model.\nupdate the state of each vehicle using the sampled action and the propagate method.\nrepeat for the desired number of steps","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    simulate\n    simulate!","category":"page"},{"location":"simulation/#AutomotiveSimulator.simulate","page":"Simulation","title":"AutomotiveSimulator.simulate","text":"simulate(\n    scene::Scene{E}, roadway::R, models::Dict{I,M}, nticks::Int64, timestep::Float64;\n    rng::AbstractRNG = Random.GLOBAL_RNG, callbacks = nothing\n) where {E<:Entity,A,R,I,M<:DriverModel}\n\nSimulate a scene. For detailed information, consult the documentation of simulate!. By default, returns a vector containing one scene per time step.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveSimulator.simulate!","page":"Simulation","title":"AutomotiveSimulator.simulate!","text":"simulate!(\n    scene::Scene{E}, roadway::R, models::Dict{I,M},\n    nticks::Int64, timestep::Float64,\n    scenes::Vector{Scene{E}}, actions::Union{Nothing, Vector{Scene{A}}} = nothing;\n    rng::AbstractRNG = Random.GLOBAL_RNG, callbacks = nothing\n) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\n\nSimulate the entities in scene along a roadway for a maximum of nticks time steps of size timestep. Returns the number of successfully performed timesteps.\n\nAt each time step, models is used to determine the action for each agent. scenes and actions are pre-allocated vectors of Scenes containing either Entitys (for scenes) or EntityActions (for actions). If actions is equal to nothing (default), the action history is not tracked. scenes must always be provided.\n\ncallbacks is an array of callback functions which are invoked before the simulation starts and after every simulation step. Any callback function can cause an early termination by returning true (the default return value for callback functions should be false). The random number generator for the simulation can be provided using the rng keyword argument, it defaults to Random.GLOBAL_RNG.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"See the tutorials for more examples.","category":"page"},{"location":"simulation/#Callbacks-1","page":"Simulation","title":"Callbacks","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"One can define callback functions that will be run at each simulation step. The callback function can terminate the simulation by returning true. The default return value of a callback function should be false. Callback functions are also useful to log simulation information. ","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"To run a custom callback function in the simulation loop, you must implement a custom callback type and an associated run_callback method for that type with the following signature","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"function AutomotiveSimulator.run_callback(\n    cb::ReachGoalCallback,\n    scenes::Vector{Scene{E}},\n    actions::Vector{Scene{A}},\n    roadway::R,\n    models::Dict{I,M},\n    tick::Int,\n    ) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\nend","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"The scenes object holds a snapshot of a scene at each timestep in the range 1:tick, and the actions object holds a scene of EntityActions which record the action of each vehicle for the time steps 1:(tick-1).","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"Here is an example of a callback that checks if a vehicle's longitudinal position has reached some goal position and stops the simulation if it is the case.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"struct ReachGoalCallback # a callback that checks if vehicle veh_id has reach a certain position \n    goal_pos::Float64\n    veh_id::Int64\nend \n\nfunction AutomotiveSimulator.run_callback(\n    cb::ReachGoalCallback,\n    scenes::Vector{Scene{E}},\n    actions::Vector{Scene{A}},\n    roadway::R,\n    models::Dict{I,M},\n    tick::Int,\n    ) where {E<:Entity,A<:EntityAction,R,I,M<:DriverModel}\n    veh = get_by_id(last(scenes), cb.veh_id)\n    return veh.state.posF.s > cb.goal_pos \nend","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"A callback for collision is already implemented: CollisionCallback.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    CollisionCallback","category":"page"},{"location":"simulation/#AutomotiveSimulator.CollisionCallback","page":"Simulation","title":"AutomotiveSimulator.CollisionCallback","text":"CollisionCallback\n\nTerminates the simulation once a collision occurs\n\n\n\n\n\n","category":"type"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    run_callback","category":"page"},{"location":"simulation/#AutomotiveSimulator.run_callback","page":"Simulation","title":"AutomotiveSimulator.run_callback","text":"run_callback(callback, scenes::Vector{EntityScene}, actions::Union{Nothing, Vector{A}}, roadway::Roadway, models::Dict{I, DriverModel}, tick::Int64)\n\nGiven a callback type, run_callback will be run at every step of a simulation run using simulate.  By overloading the run_callback method for a custom callback type one can log information or interrupt a simulation.  The run_callback function is expected to return a boolean. If true the simulation is stopped. \n\nInputs:\n\ncallback the custom callback type used for dispatch \nscenes where the simulation data is stored, note that it is only filled up to the current time step (scenes[1:tick+1])\nactions where the actions are stored, it is only filled up to actions[tick]\nroadway the roadway where entities are moving\nmodels a dictionary mapping entity IDs to driver models\ntick the index of the current time step\n\n\n\n\n\n","category":"function"},{"location":"simulation/#Woking-with-datasets-1","page":"Simulation","title":"Woking with datasets","text":"","category":"section"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"When working with datasets or pre-recorded datasets, one can replay the simulation using simulate_from_history. It allows to update the state of an ego vehicle while other vehicles follow the trajectory given in the dataset.","category":"page"},{"location":"simulation/#","page":"Simulation","title":"Simulation","text":"    simulate_from_history\n    simulate_from_history!\n    observe_from_history!\n    maximum_entities","category":"page"},{"location":"simulation/#AutomotiveSimulator.simulate_from_history","page":"Simulation","title":"AutomotiveSimulator.simulate_from_history","text":"simulate_from_history(model::DriverModel, roadway::Roadway, trajdata::Vector{Scene{E}}, egoid, timestep::Float64, \n                      start::Int = 1, stop::Int = length(trajdata);\n                      rng::AbstractRNG = Random.GLOBAL_RNG) where {E<:Entity}\n\nReplay the given trajectory except for the entity egoid which follows the given driver model.  See simulate_from_history! if you want to provide a container for the results or log actions.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveSimulator.simulate_from_history!","page":"Simulation","title":"AutomotiveSimulator.simulate_from_history!","text":"simulate_from_history!(model::DriverModel, roadway::Roadway, trajdata::Vector{Scene{E}}, egoid, timestep::Float64, \n                      start::Int, stop::Int, scenes::Vector{Scene{E}};\n                      actions::Union{Nothing, Vector{Scene{A}}} = nothing, rng::AbstractRNG = Random.GLOBAL_RNG) where {E<:Entity}\n\nReplay the given trajectory except for the entity egoid which follows the given driver model.  The resulting trajectory is stored in scenes, the actions of the ego vehicle are stored in actions.\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveSimulator.observe_from_history!","page":"Simulation","title":"AutomotiveSimulator.observe_from_history!","text":"observe_from_history!(model::DriverModel, roadway::Roadway, trajdata::Vector{<:EntityScene}, egoid, start::Int, stop::Int)\n\nGiven a prerecorded trajectory trajdata, run the observe function of a driver model for the scenes between start and stop for the vehicle of id egoid. The ego vehicle does not take any actions, it just observe the scenes,\n\n\n\n\n\n","category":"function"},{"location":"simulation/#AutomotiveSimulator.maximum_entities","page":"Simulation","title":"AutomotiveSimulator.maximum_entities","text":"maximum_entities(trajdata::Vector{<:EntityScene})\n\nreturn the maximum number of entities present in a given scene of the trajectory.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Roadways-1","page":"Roadways","title":"Roadways","text":"","category":"section"},{"location":"Roadways/#Data-Types-and-Accessing-Elements-1","page":"Roadways","title":"Data Types and Accessing Elements","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The data structure to represent roadways can be decomposed as follows:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Roadway The high level type containing all the information. It contains a list of RoadSegment.\nRoadSegment: a vector of lanes\nLane: A driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"represents a center line and a width. In addition it has attributed like speed limit. A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Lower level types:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"Curves: A curve is a list of CurvePt\nCurvePt: the lowest level type. It represents a point on a curve by its global position, position along the curve, curvature at this point and derivative of the curvature at this point. Other types like CurveIndex or CurveProjection are used to identify a curve point along a curve. ","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Roadway\n      RoadSegment\n      move_along","category":"page"},{"location":"Roadways/#AutomotiveSimulator.Roadway","page":"Roadways","title":"AutomotiveSimulator.Roadway","text":"Roadway\n\nThe main datastructure to represent road network, it consists of a list of RoadSegment\n\nFields\n\nsegments::Vector{RoadSegment}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.RoadSegment","page":"Roadways","title":"AutomotiveSimulator.RoadSegment","text":"RoadSegment{T}\n\na list of lanes forming a single road with a common direction\n\nFields\n\nid::Int64\nlanes::Vector{Lane{T}} lanes are stored right to left\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.move_along","page":"Roadways","title":"AutomotiveSimulator.move_along","text":"move_along(roadind::RoadIndex, road::Roadway, Δs::Float64)\n\nReturn the RoadIndex at ind's s position + Δs\n\n\n\n\n\nmove_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Roadway-generation-1","page":"Roadways","title":"Roadway generation","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"AutomotiveSimulator.jl provide high level functions to generate road networks by drawing straight road segment and circular curves. Two predefined road network can be generated easily: multi-lane straight roadway sections and a multi-lane stadium shaped roadway.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      gen_straight_curve\n      gen_straight_segment\n      gen_bezier_curve\n      gen_straight_roadway\n      gen_stadium_roadway","category":"page"},{"location":"Roadways/#AutomotiveSimulator.gen_straight_curve","page":"Roadways","title":"AutomotiveSimulator.gen_straight_curve","text":"gen_straight_curve(A::VecE2{T}, B::VecE2{T}, nsamples::Integer) where T<:Real\n\nReturns a Curve corresponding to a straight line between A and B. nsamples indicates the number of points to place between A and B, if set to two, the curve will only contains A and B.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.gen_straight_segment","page":"Roadways","title":"AutomotiveSimulator.gen_straight_segment","text":"gen_straight_segment(seg_id::Integer, nlanes::Integer, length::Float64=1000.0;\n\nGenerate a straight RoadSegment with nlanes number of lanes of length length.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.gen_bezier_curve","page":"Roadways","title":"AutomotiveSimulator.gen_bezier_curve","text":"gen_bezier_curve(A::VecSE2{T}, B::VecSE2{T}, rA::T, rB::T, nsamples::Int) where T <: Real\n\nGenerate a Bezier curve going from A to B with radii specified by rA and rB. It uses cubic interpolation. nsamples specifies the number of point along the curve between A and B. The more  points, the more accurate the approximation is. This is useful to generate arcs. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.gen_straight_roadway","page":"Roadways","title":"AutomotiveSimulator.gen_straight_roadway","text":"gen_straight_roadway(nlanes::Int, length::Float64)\n\nGenerate a roadway with a single straight segment whose rightmost lane center starts at starts at (0,0), and proceeds in the positive x direction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.gen_stadium_roadway","page":"Roadways","title":"AutomotiveSimulator.gen_stadium_roadway","text":"gen_stadium_roadway(nlanes::Int; length::Float64=100.0; width::Float64=10.0; radius::Float64=25.0)\n\nGenerate a roadway that is a rectangular racetrack with rounded corners.     length = length of the x-dim straight section for the innermost (leftmost) lane [m]     width  = length of the y-dim straight section for the innermost (leftmost) lane [m]     radius = turn radius [m]\n\n  ______________________\n /                      \\ \n|                        |\n|                        |\n\\______________________/\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#Lane-1","page":"Roadways","title":"Lane","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Lane data structure represent a driving lane in the roadway. The default lane width is 3m. It contains all the low level geometry information.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Lane\n      LaneTag\n      lanes\n      lanetags\n      SpeedLimit\n      LaneBoundary\n      LaneConnection\n      is_in_exits\n      is_in_entrances\n      connect!\n      is_between_segments_hi\n      is_between_segments\n      has_segment\n      has_lanetag\n      next_lane\n      prev_lane\n      has_next\n      has_prev\n      next_lane_point\n      prev_lane_point\n      n_lanes_left(roadway::Roadway, lane::Lane)\n      n_lanes_right(roadway::Roadway, lane::Lane)\n      leftlane(::Roadway, ::Lane)\n      rightlane(::Roadway, ::Lane)","category":"page"},{"location":"Roadways/#AutomotiveSimulator.Lane","page":"Roadways","title":"AutomotiveSimulator.Lane","text":"Lane\n\nA driving lane on a roadway. It identified by a LaneTag. A lane is defined by a curve which represents a center line and a width. In addition it has attributed like speed limit.  A lane can be connected to other lane in the roadway, the connection are specified in the exits and entrances fields.\n\nFields\n\ntag::LaneTag\ncurve::Curve\nwidth::Float64  [m]\nspeed_limit::SpeedLimit\nboundary_left::LaneBoundary\nboundary_right::LaneBoundary\nexits::Vector{LaneConnection} # list of exits; put the primary exit (at end of lane) first\nentrances::Vector{LaneConnection} # list of entrances; put the primary entrance (at start of lane) first\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.LaneTag","page":"Roadways","title":"AutomotiveSimulator.LaneTag","text":"LaneTag\n\nAn identifier for a lane. The lane object can be retrieved by indexing the roadway by the lane tag:\n\ntag = LaneTag(1, 2) # second lane segment 1\nlane = roadway[tag] # returns a Lane object\n\nFields\n\nsegment::Int64 segment id\nlane::Int64 index in segment.lanes of this lane\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.lanes","page":"Roadways","title":"AutomotiveSimulator.lanes","text":"lanes(roadway::Roadway{T}) where T\n\nreturn a list of all the lanes present in roadway. \n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.lanetags","page":"Roadways","title":"AutomotiveSimulator.lanetags","text":"lanetags(roadway::Roadway)\n\nreturn a list of all the lane tags present in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.SpeedLimit","page":"Roadways","title":"AutomotiveSimulator.SpeedLimit","text":"SpeedLimit\n\nDatastructure to represent a speed limit\n\nFields\n\nlo::Float64 [m/s] lower speed limit \nhi::Float64 [m/s] higher speed limit\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.LaneBoundary","page":"Roadways","title":"AutomotiveSimulator.LaneBoundary","text":"LaneBoundary\n\nData structure to represent lanes boundaries such as double yellow lines.\n\nFields\n\n- `style::Symbol` ∈ :solid, :broken, :double\n- `color::Symbol` ∈ :yellow, white\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.LaneConnection","page":"Roadways","title":"AutomotiveSimulator.LaneConnection","text":"LaneConnection{I <: Integer, T <: Real}\n\nData structure to specify the connection of a lane. It connects mylane to the point target.  target would typically be the starting point of a new lane.\n\ndownstream::Bool\nmylane::CurveIndex{I,T}\ntarget::RoadIndex{I,T}\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.is_in_exits","page":"Roadways","title":"AutomotiveSimulator.is_in_exits","text":"is_in_exits(lane::Lane, target::LaneTag)\n\nreturns true if target is in the exit lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.is_in_entrances","page":"Roadways","title":"AutomotiveSimulator.is_in_entrances","text":"is_in_entrances(lane::Lane, target::LaneTag)\n\nreturns true if target is in the entrances lanes of lane.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.connect!","page":"Roadways","title":"AutomotiveSimulator.connect!","text":"connect!(source::Lane, dest::Lane)\n\nconnect two lanes to each other. Useful for roadway construction.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.is_between_segments_hi","page":"Roadways","title":"AutomotiveSimulator.is_between_segments_hi","text":"is_between_segments_hi(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.is_between_segments","page":"Roadways","title":"AutomotiveSimulator.is_between_segments","text":"is_between_segments(ind::CurveIndex, curve::Curve)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.has_segment","page":"Roadways","title":"AutomotiveSimulator.has_segment","text":"has_segment(roadway::Roadway, segid::Int)\n\nreturns true if segid is in roadway.\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.has_lanetag","page":"Roadways","title":"AutomotiveSimulator.has_lanetag","text":"has_lanetag(roadway::Roadway, tag::LaneTag)\n\nreturns true if roadway contains a lane identified by tag\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.next_lane","page":"Roadways","title":"AutomotiveSimulator.next_lane","text":"next_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the end lane. If lane has several exits, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.prev_lane","page":"Roadways","title":"AutomotiveSimulator.prev_lane","text":"prev_lane(lane::Lane, roadway::Roadway)\n\nreturns the lane connected to the beginning lane. If lane has several entrances, it returns the first one\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.has_next","page":"Roadways","title":"AutomotiveSimulator.has_next","text":"has_next(lane::Lane)\n\nreturns true if the end of the lane is connected to another lane (i.e. if it has an exit lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.has_prev","page":"Roadways","title":"AutomotiveSimulator.has_prev","text":"has_prev(lane::Lane)\n\nreturns true if another lane is connected to the beginning of that lane. (i.e. if it has an entrance lane)\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.next_lane_point","page":"Roadways","title":"AutomotiveSimulator.next_lane_point","text":"next_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first exit\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.prev_lane_point","page":"Roadways","title":"AutomotiveSimulator.prev_lane_point","text":"prev_lane_point(lane::Lane, roadway::Roadway)\n\nreturns the point of connection between lane and its first entrance\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.n_lanes_left-Tuple{Roadway,Lane}","page":"Roadways","title":"AutomotiveSimulator.n_lanes_left","text":"n_lanes_left(roadway::Roadway, lane::Lane)\n\nreturns the number of lanes to the left of lane\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.n_lanes_right-Tuple{Roadway,Lane}","page":"Roadways","title":"AutomotiveSimulator.n_lanes_right","text":"n_lanes_right(roadway::Roadway, lane::Lane)\n\nreturns the number of lanes to the right of lane\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.leftlane-Tuple{Roadway,Lane}","page":"Roadways","title":"AutomotiveSimulator.leftlane","text":"leftlane(roadway::Roadway, lane::Lane)\n\nreturns the lane to the left of lane if it exists, returns nothing otherwise\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.rightlane-Tuple{Roadway,Lane}","page":"Roadways","title":"AutomotiveSimulator.rightlane","text":"rightlane(roadway::Roadway, lane::Lane)\n\nreturns the lane to the right of lane if it exists, returns nothing otherwise\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Frenet-frame-1","page":"Roadways","title":"Frenet frame","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The Frenet frame is a lane relative frame to represent a position on the road network.","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Frenet","category":"page"},{"location":"Roadways/#AutomotiveSimulator.Frenet","page":"Roadways","title":"AutomotiveSimulator.Frenet","text":"Frenet\n\nRepresents a vehicle position and heading in a lane relative frame. \n\nConstructors\n\nFrenet(roadind::RoadIndex, roadway::Roadway; t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(roadproj::RoadProjection, roadway::Roadway)\nFrenet(lane::Lane, s::Float64, t::Float64=0.0, ϕ::Float64=0.0)\nFrenet(posG::VecSE2, roadway::Roadway)\nFrenet(posG::VecSE2, lane::Lane, roadway::Roadway)\n\nFields\n\nroadind: road index\ns: distance along lane\nt: lane offset, positive is to left. zero point is the centerline of the lane.\nϕ: lane relative heading\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#Accessing-objects-and-projections-1","page":"Roadways","title":"Accessing objects and projections","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"The main roadway object can be indexed by different object to access different elements such as lane or curve points:","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"LaneTag: indexing roadway by a lane tag will return the lane associated to the lane tag \nRoadIndex: indexing roadway by a road index will return the curve point associated to this index","category":"page"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"  RoadIndex\n  CurveIndex\n  RoadProjection\n  proj(posG::VecSE2{T}, lane::Lane{T}, roadway::Roadway{T};move_along_curves::Bool = true ) where T<: Real\n  proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T<: Real\n  proj(posG::VecSE2{T}, roadway::Roadway) where T<: Real\n  Base.getindex(lane::Lane{T}, ind::CurveIndex{I,T}, roadway::Roadway{T}) where{I<:Integer, T<:Real}\n  Base.getindex(roadway::Roadway, segid::Int)\n  Base.getindex(roadway::Roadway, tag::LaneTag)","category":"page"},{"location":"Roadways/#AutomotiveSimulator.RoadIndex","page":"Roadways","title":"AutomotiveSimulator.RoadIndex","text":"RoadIndex{I <: Integer, T <: Real}\n\nA data structure to index points in a roadway. Calling roadway[roadind] will return the point associated to the road index.\n\nFields\n\nind::CurveIndex{I,T} the index of the point in the curve\ntag::LaneTag the lane tag of the point\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.CurveIndex","page":"Roadways","title":"AutomotiveSimulator.CurveIndex","text":"CurveIndex{I <: Integer, T <: Real}\n\nGiven a Curve object curve one can call curve[ind] where ind is a CurveIndex. The field t can be used to interpolate between two  points in the curve. \n\nFields\n\ni::I` index in the curve , ∈ [1:length(curve)-1]\nt::T ∈ [0,1] for linear interpolation\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.RoadProjection","page":"Roadways","title":"AutomotiveSimulator.RoadProjection","text":"RoadProjection{I <: Integer, T <: Real}\n\nrepresents the projection of a point on the roadway\n\nFields\n\ncurveproj::CurveProjection{I, T}\ntag::LaneTag\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},Lane{T},Roadway{T}}} where T<:Real","page":"Roadways","title":"AutomotiveSimulator.Vec.proj","text":"proj(posG::VecSE2{T}, lane::Lane, roadway::Roadway; move_along_curves::Bool=true) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the lane. This will automatically project to the next or prev curve as appropriate. if move_along_curves is false, will only project to lane.curve\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},RoadSegment,Roadway}} where T<:Real","page":"Roadways","title":"AutomotiveSimulator.Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the segment. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.Vec.proj-Union{Tuple{T}, Tuple{VecSE2{T},Roadway}} where T<:Real","page":"Roadways","title":"AutomotiveSimulator.Vec.proj","text":"proj(posG::VecSE2{T}, seg::RoadSegment, roadway::Roadway) where T <: Real\n\nReturn the RoadProjection for projecting posG onto the roadway. Tries all of the lanes and gets the closest one\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Union{Tuple{T}, Tuple{I}, Tuple{Lane{T},CurveIndex{I,T},Roadway{T}}} where T<:Real where I<:Integer","page":"Roadways","title":"Base.getindex","text":"lane[ind::CurveIndex, roadway::Roadway]\n\nAccessor for lanes based on a CurveIndex. Note that we extend the definition of a CurveIndex, previously ind.i ∈ [1, length(curve)-1], to:\n\nind.i ∈ [0, length(curve)]\n\nwhere 1 ≤ ind.i ≤ length(curve)-1 is as before, but if the index is on the section between two lanes, we use:\n\nind.i = length(curve), ind.t ∈ [0,1] for the region between curve[end] → next\nind.i = 0,             ind.t ∈ [0,1] for the region between prev → curve[1]\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,Int64}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, segid::Int)\n\nreturns the segment associated with id segid\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.getindex-Tuple{Roadway,LaneTag}","page":"Roadways","title":"Base.getindex","text":"Base.getindex(roadway::Roadway, tag::LaneTag)\n\nreturns the lane identified by the tag LaneTag\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Low-level-1","page":"Roadways","title":"Low level","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Curve\n      CurvePt\n      CurveProjection\n      is_at_curve_end\n      get_lerp_time\n      index_closest_to_point\n      get_curve_index\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, D::VecE2{T}, t::T) where T<:Real\n      lerp(A::VecE2{T}, B::VecE2{T}, C::VecE2{T}, t::T) where T<:Real","category":"page"},{"location":"Roadways/#AutomotiveSimulator.Curve","page":"Roadways","title":"AutomotiveSimulator.Curve","text":"Curve{T}\n\nis a vector of curve points\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.CurvePt","page":"Roadways","title":"AutomotiveSimulator.CurvePt","text":"CurvePt{T}\n\ndescribes a point on a curve, associated with a curvature and the derivative of the curvature\n\npos::VecSE2{T} # global position and orientation\ns::T  # distance along the curve\nk::T # curvature\nkd::T # derivative of curvature\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.CurveProjection","page":"Roadways","title":"AutomotiveSimulator.CurveProjection","text":"CurveProjection{I <: Integer, T <: Real}\n\nThe result of a point projected to a Curve\n\nFields\n\nind::CurveIndex{I, T}\nt::T lane offset \nϕ::T lane-relative heading [rad]\n\n\n\n\n\n","category":"type"},{"location":"Roadways/#AutomotiveSimulator.is_at_curve_end","page":"Roadways","title":"AutomotiveSimulator.is_at_curve_end","text":"is_at_curve_end(ind::CurveIndex, curve::Curve)\n\nreturns true if the curve index is at the end of the curve\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.get_lerp_time","page":"Roadways","title":"AutomotiveSimulator.get_lerp_time","text":"get_lerp_time(A::VecE2, B::VecE2, Q::VecE2)\n\nGet lerp time t∈[0,1] such that lerp(A, B) is as close as possible to Q\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.index_closest_to_point","page":"Roadways","title":"AutomotiveSimulator.index_closest_to_point","text":"index_closest_to_point(curve::Curve, target::AbstractVec)\n\nreturns the curve index closest to the point described by target. target must be [x, y].\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.get_curve_index","page":"Roadways","title":"AutomotiveSimulator.get_curve_index","text":"get_curve_index(curve::Curve{T}, s::T) where T <: Real\n\nReturn the CurveIndex for the closest s-location on the curve\n\n\n\n\n\nget_curve_index(ind::CurveIndex, curve::Curve, Δs::T) where T <: Real\n\nReturn the CurveIndex at ind's s position + Δs\n\n\n\n\n\n","category":"function"},{"location":"Roadways/#AutomotiveSimulator.Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"AutomotiveSimulator.Vec.lerp","text":"cubic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#AutomotiveSimulator.Vec.lerp-Union{Tuple{T}, Tuple{VecE2{T},VecE2{T},VecE2{T},T}} where T<:Real","page":"Roadways","title":"AutomotiveSimulator.Vec.lerp","text":"quadratic bezier lerp\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Read-and-Write-roadways-1","page":"Roadways","title":"Read and Write roadways","text":"","category":"section"},{"location":"Roadways/#","page":"Roadways","title":"Roadways","text":"      Base.read(io::IO, ::Type{Roadway})\n      Base.write(io::IO, roadway::Roadway)","category":"page"},{"location":"Roadways/#Base.read-Tuple{IO,Type{Roadway}}","page":"Roadways","title":"Base.read","text":"Base.read(io::IO, ::Type{Roadway})\n\nextract roadway information from a text file and returns a roadway object.\n\n\n\n\n\n","category":"method"},{"location":"Roadways/#Base.write-Tuple{IO,Roadway}","page":"Roadways","title":"Base.write","text":"Base.write(io::IO, roadway::Roadway)\n\nwrite all the roadway information to a text file\n\n\n\n\n\n","category":"method"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/intersection.jl\"","category":"page"},{"location":"tutorials/intersection/#Intersection-1","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: )","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"In this example we demonstrate how to define a T-shape intersection with AutomotiveSimulator. You will also learn how to define your own custom action type and driver model type.","category":"page"},{"location":"tutorials/intersection/#Generate-a-T-Shape-intersection-1","page":"Intersection","title":"Generate a T-Shape intersection","text":"","category":"section"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"In order to generate the road network, we first initialize a Roadway object.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"using AutomotiveSimulator\nusing AutomotiveVisualization\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Random\n\nroadway = Roadway()\nnothing # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Define coordinates of the entry and exit points to the intersection","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"r = 5.0 # turn radius\nw = DEFAULT_LANE_WIDTH\n\nA = VecSE2(0.0,w,-π)\nB = VecSE2(0.0,0.0,0.0)\nC = VecSE2(r,-r,-π/2)\nD = VecSE2(r+w,-r,π/2)\nE = VecSE2(2r+w,0,0)\nF = VecSE2(2r+w,w,-π)\nnothing # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"The next step consists in appending all the lanes to the road network. We can define a helper function to add a new lane to the roadway.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"function append_to_curve!(target::Curve, newstuff::Curve)\n    s_end = target[end].s\n    for c in newstuff\n        push!(target, CurvePt(c.pos, c.s+s_end, c.k, c.kd))\n    end\n    return target\nend\nnothing # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Example of a lane that consists of 3 road segments, a straight curve (from the left to the center), a turning part (right turn) and a final straight curve.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append right turn coming from the left","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)\nappend_to_curve!(curve, gen_bezier_curve(B, C, 0.6r, 0.6r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50.0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"visualize the current lane constellation","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"snapshot = render([roadway])\nwrite(\"partial_intersection.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: partial intersection)","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Let's repeat the process and complete the T-shape intersection","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append straight left","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, B), convert(VecE2, E), 2)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append straight right","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, F), convert(VecE2, A), 2)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append left turn coming from the right","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)\nappend_to_curve!(curve, gen_bezier_curve(F, C, 0.9r, 0.9r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append right turn coming from below","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)\nappend_to_curve!(curve, gen_bezier_curve(D, E, 0.6r, 0.6r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Append left turn coming from below","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)\nappend_to_curve!(curve, gen_bezier_curve(D, A, 0.9r, 0.9r, 51)[2:end])\nappend_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))\nlane = Lane(LaneTag(length(roadway.segments)+1,1), curve)\npush!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))\n\nsnapshot = render([roadway])\nwrite(\"intersection.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: intersection)","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"We can identify each lane thanks to the following user-defined functions. We define a LaneOverlay object that indicate the lane to highlight. One could implement any custom type to display other information on the lane. We then add a new method to the add_renderable! function that execute the specific action (coloring in blue). Look at AutomotiveVisualization.jl for more detail on the function add_renderable!.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"The following animation iterates over the individual lanes of the intersection layout and highlights them:","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"struct LaneOverlay\n    roadway::Roadway\n    lane::Lane\n    color::Colorant\nend\nfunction AutomotiveVisualization.add_renderable!(rendermodel::RenderModel, overlay::LaneOverlay)\n    add_renderable!(rendermodel, overlay.lane, overlay.roadway, color_asphalt=overlay.color)\nend\n\n\nusing Reel\n\nanimation = roll(fps=1.0, duration=length(roadway.segments)) do t, dt\n    i = Int(floor(t/dt)) + 1\n    renderables = [\n        roadway,\n        LaneOverlay(roadway, roadway[LaneTag(i,1)], RGBA(0.0,0.0,1.0,0.5))\n    ]\n    render(renderables)\nend;\n\nwrite(\"highlighted_lanes.gif\", animation) # hide\nnothing # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: highlighted lanes)","category":"page"},{"location":"tutorials/intersection/#Navigation-in-the-new-road-network-1","page":"Intersection","title":"Navigation in the new road network","text":"","category":"section"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Let's populate the intersection","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0) # initial state of the vehicle\nscene = Scene([Entity(vs0, VehicleDef(), 1)])\n\nsnapshot = render([roadway, scene])\nwrite(\"intersection_populated.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: populated intersection)","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"We will use lateral and longitudinal acceleration to control a car in the intersection. The first step is to define a corresponding action type that will contain the acceleration inputs.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"struct LaneSpecificAccelLatLon\n    a_lat::Float64\n    a_lon::Float64\nend","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Next, add a method to the propagate function to update the state using our new action type.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"function AutomotiveSimulator.propagate(veh::Entity, action::LaneSpecificAccelLatLon, roadway::Roadway, Δt::Float64)\n    lane_tag_orig = veh.state.posF.roadind.tag\n    state = propagate(veh, LatLonAccel(action.a_lat, action.a_lon), roadway, Δt)\n    roadproj = proj(state.posG, roadway[lane_tag_orig], roadway, move_along_curves=false)\n    retval = VehicleState(Frenet(roadproj, roadway), roadway, state.v)\n    return retval\nend","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Driver Model:","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"We define a driver model, which can be seen as a distribution over actions.  # TODO Here we will define the simplest model, which is to repeat the same action.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"struct InterDriver <: DriverModel{LaneSpecificAccelLatLon}\n    a::LaneSpecificAccelLatLon\nend\n\nAutomotiveSimulator.observe!(model::InterDriver, scene::Scene, roadway::Roadway, egoid::Int64) = model\nBase.rand(::AbstractRNG, model::InterDriver) = model.a","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"Simulate:","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"First associate a model to each driver in the scene using a dictionary. Here we only have one driver identified by its ID: 1. Then everything is ready to run the simulate! function.","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"using Reel\n\ntimestep = 0.1\nnticks = 100\n\nvs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0)\nscene = Scene([Entity(vs0, VehicleDef(), 1)])\nmodels = Dict(1 => InterDriver(LaneSpecificAccelLatLon(0.0,0.0)))\nscenes = simulate(scene, roadway, models, nticks, timestep)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    renderables = [roadway, scenes[i]]\n    render(renderables)\nend\n\nwrite(\"animated_intersection.gif\", animation) # hide","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"(Image: animated intersection)","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"","category":"page"},{"location":"tutorials/intersection/#","page":"Intersection","title":"Intersection","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/stadium.jl\"","category":"page"},{"location":"tutorials/stadium/#Driving-in-a-Stadium-1","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"","category":"section"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: )","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"This example demonstrates a 2D driving simulation where cars drive around a three-lane stadium. The entities are defined by the types:","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"S - VehicleState, containing the vehicle position (both globally and relative to the lane) and speed\nD - VehicleDef, containing length, width, and class\nI - Symbol, a unique label for each vehicle","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The environment is represented by a Roadway object which allows to define roads consisting of multiple lanes based on the RNDF format.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"We load relevant modules and generate a 3-lane stadium roadway:","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using AutomotiveSimulator\nusing AutomotiveVisualization\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Distributions\n\nroadway = gen_stadium_roadway(3)\nsnapshot = render([roadway])\nwrite(\"stadium.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: three lane stadium)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"As a next step, let's populate a scene with vehicles","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"w = DEFAULT_LANE_WIDTH\nscene = Scene([\n    Entity(VehicleState(VecSE2(10.0,  -w, 0.0), roadway, 29.0), VehicleDef(), :alice),\n    Entity(VehicleState(VecSE2(40.0, 0.0, 0.0), roadway, 22.0), VehicleDef(), :bob),\n    Entity(VehicleState(VecSE2(30.0, -2w, 0.0), roadway, 27.0), VehicleDef(), :charlie),\n])\ncar_colors = get_pastel_car_colors(scene)\nrenderables = [\n    roadway,\n    (FancyCar(car=veh, color=car_colors[veh.id]) for veh in scene)...\n]\nsnapshot = render(renderables)\nwrite(\"stadium_with_cars.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: stadium with cars)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"We can assign driver models to each agent and simulate the scenario.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"timestep = 0.1\nnticks = 300\n\nmodels = Dict{Symbol, DriverModel}(\n    :alice => LatLonSeparableDriver( # produces LatLonAccels\n        ProportionalLaneTracker(), # lateral model\n        IntelligentDriverModel(), # longitudinal model\n    ),\n    :bob => Tim2DDriver(\n         mlane = MOBIL(),\n    ),\n    :charlie => StaticDriver{AccelTurnrate, MvNormal}(\n        MvNormal([0.0,0.0], [1.0,0.1])\n    )\n)\n\nset_desired_speed!(models[:alice],   12.0)\nset_desired_speed!(models[:bob],     10.0)\nset_desired_speed!(models[:charlie],  8.0)\n\nscenes = simulate(scene, roadway, models, nticks, timestep)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"md nothing # hide","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"An animation of the simulation can be rendered using the Reel package","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using Reel\nusing Printf\n\ncamera = TargetFollowCamera(:alice; zoom=10.)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    update_camera!(camera, scenes[i])\n    renderables = [\n        roadway,\n        (FancyCar(car=veh, color=car_colors[veh.id]) for veh in scenes[i])...,\n        IDOverlay(x_off=-2, y_off=1, scene=scenes[i]),\n        TextOverlay(text=[@sprintf(\"time: %.1fs\", t)], pos=VecE2(40,40), font_size=24)\n    ]\n    render(renderables, camera=camera)\nend\n\nwrite(\"animated_stadium.gif\", animation) # hide","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: animated stadium with cars)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"Alternatively, one can also use the Interact framework to inspect the simulation record interactively.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"using Interact\nusing Reel\nusing Blink\n#md\nw = Window()\nviz = @manipulate for step in 1 : length(scenes)\n    render([roadway, scenes[step]])\nend\nbody!(w, viz)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The simulation results can be saved to a text file. Only entities using VehicleState and VehicleDef are supported out of the box. If you wish to do IO operation with different states and definition types you have to implement Base.write and Base.read for those new types.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"open(\"2Dstadium_listrec.txt\", \"w\") do io\n    write(io, scenes)\nend","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"The trajectory data file can be loaded in a similar way. You need to specify the output type.","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"loaded_scenes = open(\"2Dstadium_listrec.txt\", \"r\") do io\n    read(io, Vector{EntityScene{VehicleState, VehicleDef, String}})\nend\nrender([roadway, loaded_scenes[1]])\nwrite(\"stadium_with_cars_loaded.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"(Image: stadium with cars after load)","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"","category":"page"},{"location":"tutorials/stadium/#","page":"Driving in a Stadium","title":"Driving in a Stadium","text":"This page was generated using Literate.jl.","category":"page"},{"location":"collision_checkers/#Collision-Checker-1","page":"Collision Checker","title":"Collision Checker","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"There are two collisions checkers currently available in AutomotiveSimulator.jl.  The first collision checker is accessible through the function is_colliding and relies on Minkowski sum.  The second one is accessible through collision_checker and uses the parallel axis theorem. The latter is a bit faster.  A benchmark script is available in test/collision_checkers_benchmark.jl and relies on static arrays. ","category":"page"},{"location":"collision_checkers/#Parallel-Axis-Theorem-1","page":"Collision Checker","title":"Parallel Axis Theorem","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"This collision checker relies on the parallel axis theorem. It checks that two convex polygon overlap","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    collision_checker","category":"page"},{"location":"collision_checkers/#AutomotiveSimulator.collision_checker","page":"Collision Checker","title":"AutomotiveSimulator.collision_checker","text":"collision_checker(veh_a::Entity, veh_b::Entity)\ncollision_checker(veh_a, veh_b, veh_a_def::AbstractAgentDefinition, veh_b_def::AbstractAgentDefinition)\n\nreturn True if veh_a and veh_b collides. Relies on the parallel axis theorem.\n\n\n\n\n\ncollision_checker(scene::Scene{Entity{S,D,I}}, egoid::I) where {S, D<:AbstractAgentDefinition, I}\n\nreturn true if any entity in the scene collides with the entity of id egoid.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Vehicles can be converted to polygon (static matrices containing four vertices).","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    polygon","category":"page"},{"location":"collision_checkers/#AutomotiveSimulator.polygon","page":"Collision Checker","title":"AutomotiveSimulator.polygon","text":"polygon(pos::VecSE2{Float64}, veh_def::AbstractAgentDefinition)\npolygon(x::Float64,y::Float64,theta::Float64, length::Float64, width::Float64)\n\nreturns a 4x2 static matrix corresponding to a rectangle around a car centered at pos and of dimensions specified by veh_def\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#Minkowski-Sum-1","page":"Collision Checker","title":"Minkowski Sum","text":"","category":"section"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"Here are the methods available using Minkowski sum.","category":"page"},{"location":"collision_checkers/#","page":"Collision Checker","title":"Collision Checker","text":"    is_colliding\n    ConvexPolygon\n    CPAMemory\n    CollisionCheckResult\n    to_oriented_bounding_box!\n    get_oriented_bounding_box\n    is_potentially_colliding\n    get_collision_time\n    get_first_collision\n    is_collision_free\n    get_distance\n    get_edge","category":"page"},{"location":"collision_checkers/#AutomotiveSimulator.is_colliding","page":"Collision Checker","title":"AutomotiveSimulator.is_colliding","text":"is_colliding(ray::VecSE2{Float64}, poly::ConvexPolygon)\n\nreturns true if the ray collides with the polygon\n\n\n\n\n\nis_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns true if the vehicles A and B are colliding. It uses Minkowski sums.     is_colliding(mem::CPAMemory) returns true if vehA and vehB in mem collides.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.ConvexPolygon","page":"Collision Checker","title":"AutomotiveSimulator.ConvexPolygon","text":"ConvexPolygon\nConvexPolygon(npts::Int)\nConvexPolygon(pts::Vector{VecE2{Float64}})\n\nMutable structure to represent a convex polygon. It is used by the Minkowski sum collision checker\n\nFields\n\npts::Vector{VecE2{Float64}}\nnpts::Int\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveSimulator.CPAMemory","page":"Collision Checker","title":"AutomotiveSimulator.CPAMemory","text":"CPAMemory\n\nA structure to cache the bounding boxes around vehicle. It is part of the internals of the  Minkowski collision checker.\n\nFields\n\nvehA::ConvexPolygon bounding box for vehicle A\nvehB::ConvexPolygon bounding box for vehicle B\nmink::ConvexPolygon minkowski bounding box\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveSimulator.CollisionCheckResult","page":"Collision Checker","title":"AutomotiveSimulator.CollisionCheckResult","text":"CollisionCheckResult\n\nA type to store the result of a collision checker\n\nFields\n\nis_colliding::Bool\nA::Int64 # index of 1st vehicle\nB::Int64 # index of 2nd vehicle\n\n\n\n\n\n","category":"type"},{"location":"collision_checkers/#AutomotiveSimulator.to_oriented_bounding_box!","page":"Collision Checker","title":"AutomotiveSimulator.to_oriented_bounding_box!","text":"to_oriented_bounding_box!(retval::ConvexPolygon, center::VecSE2{Float64}, len::Float64, wid::Float64)\nto_oriented_bounding_box!(retval::ConvexPolygon, veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))\n\nFills in the vertices of retval according to the rectangle specification: center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.get_oriented_bounding_box","page":"Collision Checker","title":"AutomotiveSimulator.get_oriented_bounding_box","text":"get_oriented_bounding_box(center::VecSE2{Float64}, len::Float64, wid::Float64) = to_oriented_bounding_box!(ConvexPolygon(4), center, len, wid)\nget_oriented_bounding_box(veh::Entity{S,D,I}, center::VecSE2{Float64} = get_center(veh))  where {S,D<:AbstractAgentDefinition,I}\n\nReturns a ConvexPolygon representing a bounding rectangle of the size specified by center, length, width\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.is_potentially_colliding","page":"Collision Checker","title":"AutomotiveSimulator.is_potentially_colliding","text":"is_potentially_colliding(A::Entity{S,D,I}, B::Entity{S,D,I}) where {S,D<:AbstractAgentDefinition,I}\n\nA fast collision check to remove things clearly not colliding\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.get_collision_time","page":"Collision Checker","title":"AutomotiveSimulator.get_collision_time","text":"get_collision_time(ray::VecSE2{Float64}, poly::ConvexPolygon, ray_speed::Float64)\n\nreturns the collision time between a ray and a polygon given ray_speed\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.get_first_collision","page":"Collision Checker","title":"AutomotiveSimulator.get_first_collision","text":"get_first_collision(scene::EntityScene{S,D,I}, target_index::Int, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between a vehicle and scene[target_index]\n\n\n\n\n\nget_first_collision(scene::EntityScene{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles in vehicle_indeces.\n\n\n\n\n\nget_first_collision(scene::EntityScene{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nLoops through the scene and finds the first collision between any two vehicles\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.is_collision_free","page":"Collision Checker","title":"AutomotiveSimulator.is_collision_free","text":"is_collision_free(scene::EntityScene{S,D,I}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\nis_collision_free(scene::EntityScene{S,D,I}, vehicle_indeces::AbstractVector{Int}, mem::CPAMemory=CPAMemory()) where {S,D<:AbstractAgentDefinition,I}\n\nCheck that there is no collisions between any two vehicles in scene\n\nIf vehicle_indeces is used, it only checks for vehicles within scene[vehicle_indeces]\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.Vec.get_distance","page":"Collision Checker","title":"AutomotiveSimulator.Vec.get_distance","text":"The distance between the line segment and the point P\n\n\n\n\n\nThe distance between the line and the point P\n\n\n\n\n\nThe distance between the line segment and the point P\n\n\n\n\n\nReturns the absolute distance between the plane and a point\n\n\n\n\n\nVec.get_distance(A::Entity{S,D,I}, B::Entity{S,D,I}, mem::CPAMemory=CPAMemory()) where {D<:AbstractAgentDefinition,I}\n\nreturns the euclidean distance between A and B.\n\n\n\n\n\n","category":"function"},{"location":"collision_checkers/#AutomotiveSimulator.get_edge","page":"Collision Checker","title":"AutomotiveSimulator.get_edge","text":"get_edge(pts::Vector{VecE2{Float64}}, i::Int, npts::Int=length(pts))\n\nreturns the ith edge in pts\n\n\n\n\n\n","category":"function"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/feature_extraction.jl\"","category":"page"},{"location":"tutorials/feature_extraction/#Feature-Extraction-1","page":"Feature Extraction","title":"Feature Extraction","text":"","category":"section"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"(Image: )","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"In this example we demonstrate how to extract feature from trajectories using AutomotiveSimulator","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"Load a Dataset First let's create a synthetic dataset.","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"using AutomotiveSimulator\nusing AutomotiveVisualization\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Random\n\nroadway = roadway = gen_straight_roadway(3, 1000.0)\nveh_state = VehicleState(Frenet(roadway[LaneTag(1,2)], 0.0), roadway, 10.)\nveh1 = Entity(veh_state, VehicleDef(), \"bob\")\nveh_state = VehicleState(Frenet(roadway[LaneTag(1,2)], 20.0), roadway, 2.)\nveh2 = Entity(veh_state, VehicleDef(), \"alice\")\n\ndt = 0.5\nn_steps = 10\nmodels = Dict{String, DriverModel}()\nmodels[\"bob\"] = Tim2DDriver(mlane=MOBIL())\nset_desired_speed!(models[\"bob\"], 10.0)\nmodels[\"alice\"] = Tim2DDriver(mlane=MOBIL())\nset_desired_speed!(models[\"alice\"], 2.0)\n\nscene = Scene([veh1, veh2])\nscenes = simulate(scene, roadway, models, n_steps, dt)\ncamera = SceneFollowCamera()\nupdate_camera!(camera, scene)\nsnapshot = render([roadway, scene], camera=camera)\nwrite(\"feature_initial.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"(Image: initial state of feature extraction scenario)","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"nothing # hide","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"One can also load the data from the Stadium tutorial","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"load data from stadium tutorial\nscenes = open(\"2Dstadium_listrec.txt\", \"r\") do io\n    read(io, Vector{EntityScene{VehicleState, VehicleDef, String}})\nend","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"Extract features from a recorded trajectory Recorded trajectories are expected to be vectors of Scenes where each element correspond to one time step. To extract features, one can use the extract_features function which takes as input a list of feature we want to extract and the list of vehicle ids for which we want those features. For this example, let's first query two features, the longitudinal and lateral position of Bob, and whether or not Bob is colliding:","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"dfs = extract_features((posfs, posft, iscolliding), roadway, scenes, [\"bob\"])\ndfs[\"bob\"]","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"To query features for all traffic participants we can just add their ID to the list:","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"dfs = extract_features((posfs, posft, iscolliding), roadway, scenes, [\"bob\", \"alice\"])\ndfs[\"alice\"]","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"The output is a dictionary mapping ID to dataframes. To learn more about DataFrames visit DataFrames.jl.","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"For the list of all possible features available see the documentation. Features are generally just function. AutomotiveSimulator provides some convenience to automatically generate feature function like distance_to_$x The distance_to function takes as input a vehicle ID and returns a function to extract the distance between the queried vehicle and the vehicle given to distance_to","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"distance_to(\"alice\")","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"we can use this newly generated funciton in the feature extraction pipeline","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"dfs = extract_features((distance_to_alice, posfs), roadway, scenes, [\"bob\"])\ndfs[\"bob\"].distance_to_alice[1] # distance between Bob and Alice in the first scene.","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"","category":"page"},{"location":"tutorials/feature_extraction/#","page":"Feature Extraction","title":"Feature Extraction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/crosswalk.jl\"","category":"page"},{"location":"tutorials/crosswalk/#Crosswalk-1","page":"Crosswalk","title":"Crosswalk","text":"","category":"section"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: )","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"In this notebook we demonstrate how to define a crosswalk with pedestrians using AutomotiveSimulator. To do this, we define a crosswalk area as well as a pedestrian agent type.","category":"page"},{"location":"tutorials/crosswalk/#Generate-a-crosswalk-environment-1","page":"Crosswalk","title":"Generate a crosswalk environment","text":"","category":"section"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"We define a new concrete type that will contain the roadway (where cars drive) and the crosswalk definition which is just a regular lane.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using AutomotiveSimulator\nusing AutomotiveVisualization\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Random\n\nstruct CrosswalkEnv\n    roadway::Roadway{Float64}\n    crosswalk::Lane{Float64}\nend","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"The crosswalk lane consists of a straight road segment perpendicular to the road. We will define the roadway just as a straight road.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"geometry parameters","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"roadway_length = 50.\ncrosswalk_length = 20.\ncrosswalk_width = 6.0\ncrosswalk_pos = roadway_length/2","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Generate a straight 2-lane roadway and a crosswalk lane","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"roadway = gen_straight_roadway(2, roadway_length)\ncrosswalk_start = VecE2(crosswalk_pos, -crosswalk_length/2)\ncrosswalk_end = VecE2(crosswalk_pos, crosswalk_length/2)\ncrosswalk_lane = gen_straight_curve(crosswalk_start, crosswalk_end, 2)\ncrosswalk = Lane(LaneTag(2,1), crosswalk_lane, width = crosswalk_width)\ncw_segment = RoadSegment(2, [crosswalk])\npush!(roadway.segments, cw_segment) # append it to the roadway","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"initialize crosswalk environment","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"env = CrosswalkEnv(roadway, crosswalk)\nnothing # hide","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Render the crosswalk","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"We will define a new method to render this new environment. The roadway part is just rendered regularly, we add specific instuction for the crosswalk part that will display the white stripes.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using Cairo\n\nfunction AutomotiveVisualization.add_renderable!(rendermodel::RenderModel, env::CrosswalkEnv)\n\n    # render the road without the crosswalk\n    roadway = gen_straight_roadway(2, roadway_length)\n    add_renderable!(rendermodel, roadway)\n\n    # render crosswalk\n    curve = env.crosswalk.curve\n    n = length(curve)\n    pts = Array{Float64}(undef, 2, n)\n    for (i,pt) in enumerate(curve)\n        pts[1,i] = pt.pos.x\n        pts[2,i] = pt.pos.y\n    end\n\n    add_instruction!(\n        rendermodel, render_dashed_line,\n        (pts, colorant\"white\", env.crosswalk.width, 1.0, 1.0, 0.0, Cairo.CAIRO_LINE_CAP_BUTT)\n    )\n    return rendermodel\nend\n\nsnapshot = render([env])\nwrite(\"crosswalk.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: crosswalk)","category":"page"},{"location":"tutorials/crosswalk/#Navigate-the-crosswalk-example-1","page":"Crosswalk","title":"Navigate the crosswalk example","text":"","category":"section"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Cars will be navigating in the roadway just as before. For the pedestrian we can define a new vehicle definition where we specify the size of the bounding box represented by the pedestrian.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"field of the VehicleDef type","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"fieldnames(VehicleDef)\n# Agent.Class is from AutomotiveSimulator\nconst PEDESTRIAN_DEF = VehicleDef(AgentClass.PEDESTRIAN, 1.0, 1.0)\nnothing # hide","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Car definition","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"car_initial_state = VehicleState(VecSE2(5.0, 0., 0.), roadway.segments[1].lanes[1],roadway, 8.0)\ncar = Entity(car_initial_state, VehicleDef(), :car)","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"Pedestrian definition using our new Vehicle definition","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"ped_initial_state = VehicleState(VecSE2(+24.5,-7.0,π/2), env.crosswalk, roadway, 0.5)\nped = Entity(ped_initial_state, PEDESTRIAN_DEF, :pedestrian)\n\nscene = Scene([car, ped])","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"visualize the initial state","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"snapshot = render([env, scene])\nwrite(\"crosswalk_initial.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: initial state of crosswalk)","category":"page"},{"location":"tutorials/crosswalk/#Simulate-the-scenario-1","page":"Crosswalk","title":"Simulate the scenario","text":"","category":"section"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"As before, associate a driver model to each vehicle in the scene. We will use the model defined in the intersection example for both agents.","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"mutable struct LinearDriver <: DriverModel{LaneFollowingAccel}\n    a::LaneFollowingAccel\n    p::Float64 # confidence on the pedestrian intention\n    k::Float64 # gain\nend\n\nfunction AutomotiveSimulator.observe!(model::LinearDriver, scene::Scene, roadway::Roadway, egoid)\n    model.a = LaneFollowingAccel(model.k*model.p)\n    # change the confidence based on some policy\n    # you can get the position of the pedestrian from the scene\n    model.p = 100.0\nend\nBase.rand(rng::AbstractRNG, model::LinearDriver) = model.a\n\ntimestep = 0.1\nnticks = 50\n\n# define a model for each entities present in the scene\nmodels = Dict{Symbol, DriverModel}()\n\n# Constant speed model\nmodels[:car] = LinearDriver(LaneFollowingAccel(0.0), 20.0, -0.02)\nmodels[:pedestrian] = IntelligentDriverModel(v_des=1.0)\n\n# execute the simulation\nscenes = simulate(scene, roadway, models, nticks, timestep)\nnothing # hide","category":"page"},{"location":"tutorials/crosswalk/#Generate-a-video-with-Reel.jl-1","page":"Crosswalk","title":"Generate a video with Reel.jl","text":"","category":"section"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"using Reel\n\nfunction animate_record(scenes::Vector{Scene{E}},dt::Float64, env::CrosswalkEnv) where {E<:Entity}\n    duration = length(scenes)*dt::Float64\n    fps = Int(1/dt)\n    function render_rec(t, dt)\n        frame_index = Int(floor(t/dt)) + 1\n        return render([env, scenes[frame_index]])\n    end\n    return duration, fps, render_rec\nend\n\nduration, fps, render_hist = animate_record(scenes, timestep, env)\nfilm = roll(render_hist, fps=fps, duration=duration)\nwrite(\"crosswalk_animated.gif\", film) # hide\nnothing # hide","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"(Image: animated crosswalk)","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"","category":"page"},{"location":"tutorials/crosswalk/#","page":"Crosswalk","title":"Crosswalk","text":"This page was generated using Literate.jl.","category":"page"},{"location":"agent_definitions/#Agent-Definition-1","page":"Agent Definition","title":"Agent Definition","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent Definitions describe the static properties of a traffic participants such as the length and width of the vehicle. It also contains information on the type of agent (car, pedestrian, motorcycle...).","category":"page"},{"location":"agent_definitions/#Interface-1","page":"Agent Definition","title":"Interface","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"You can implement your own agent definition by creating a new type inheriting from the AbstractAgentDefinition type. The following three functions must be implemented for your custom type:","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AbstractAgentDefinition\n    length\n    width\n    class","category":"page"},{"location":"agent_definitions/#AutomotiveSimulator.AbstractAgentDefinition","page":"Agent Definition","title":"AutomotiveSimulator.AbstractAgentDefinition","text":"AbstractAgentDefinition\n\nAn Agent definition represents static parameters characterizing an agent,  such as its physical dimensions.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#Base.length","page":"Agent Definition","title":"Base.length","text":"length(def::AbstractAgentDefinition)\n\nreturn the length of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveSimulator.width","page":"Agent Definition","title":"AutomotiveSimulator.width","text":"width(def::AbstractAgentDefinition)\n\nreturn the width of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#AutomotiveSimulator.class","page":"Agent Definition","title":"AutomotiveSimulator.class","text":"class(def::AbstractAgentDefinition)\n\nreturn the class of the vehicle \n\n\n\n\n\n","category":"function"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"Agent classes such as car, truck, and pedestrian are defined by integer constant in a submodule AgentClass.","category":"page"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    AgentClass","category":"page"},{"location":"agent_definitions/#AutomotiveSimulator.AgentClass","page":"Agent Definition","title":"AutomotiveSimulator.AgentClass","text":"A module to represent the different class of agents:\n\nMotorcycle\nCar\nTruck\nPedestrian\n\n\n\n\n\n","category":"module"},{"location":"agent_definitions/#Available-Agent-Definitions-1","page":"Agent Definition","title":"Available Agent Definitions","text":"","category":"section"},{"location":"agent_definitions/#","page":"Agent Definition","title":"Agent Definition","text":"    VehicleDef\n    BicycleModel","category":"page"},{"location":"agent_definitions/#AutomotiveSimulator.VehicleDef","page":"Agent Definition","title":"AutomotiveSimulator.VehicleDef","text":"VehicleDef(;class::Float64, length::Float64, width::Float64)\n\nVehicle definition which contains a class and a bounding box.\n\n\n\n\n\n","category":"type"},{"location":"agent_definitions/#AutomotiveSimulator.BicycleModel","page":"Agent Definition","title":"AutomotiveSimulator.BicycleModel","text":"BicycleModel\nBicycleModel(def::VehicleDef; a::Float64 = 1.5, b::Float64 = 1.5)\n\nVehicle definition representing the bicycle model\n\nFields\n\ndef::VehicleDef\na::Float64 distance between cg and front axle [m]\nb::Float64 distance between cg and rear axle [m]\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Behaviors-1","page":"Behaviors","title":"Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These stands one level above the actions. They provide a higher level decision that the actions then implement in order to propagate the simulation forward.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"A behavior model can be interpreted as a control law. Given the current scene, representing all  the vehicles present in the environment, a behavior model returns an action to execute. ","category":"page"},{"location":"behaviors/#Interface-1","page":"Behaviors","title":"Interface","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"We provide an interface to interact with behavior model or implement your own. To implement your own driver model you can create a type that inherits from the abstract type DriverModel. Then you can implement the following methods:","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    DriverModel{DriveAction}\n    action_type(::DriverModel{A}) where A\n    set_desired_speed!\n    reset_hidden_state!\n    reset_hidden_states!\n    observe!\n    Base.rand(model::DriverModel)","category":"page"},{"location":"behaviors/#AutomotiveSimulator.DriverModel","page":"Behaviors","title":"AutomotiveSimulator.DriverModel","text":"DriverModel{DriveAction}\n\nA DriverModel represents a specific driving behavior.  It specifies the action taken by the agent at a given scene. The ation will be of type DriveAction. It can be interpreted as a distribution, the likelihood of taking a certain action  in a given scene.  The DriverModel type is an abstract type! Custom driver models should inherit from it.\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#AutomotiveSimulator.action_type-Union{Tuple{DriverModel{A}}, Tuple{A}} where A","page":"Behaviors","title":"AutomotiveSimulator.action_type","text":"action_type(::DriverModel{A}) where {A}\n\nreturns the type of the actions that are sampled from the model\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#AutomotiveSimulator.set_desired_speed!","page":"Behaviors","title":"AutomotiveSimulator.set_desired_speed!","text":"set_desired_speed!(model::DriverModel, v_des::Float64)\n\nSets a desired speed. This method is relevant for models like IDM where the vehicle tracks a nominal speed.\n\n\n\n\n\n","category":"function"},{"location":"behaviors/#AutomotiveSimulator.reset_hidden_state!","page":"Behaviors","title":"AutomotiveSimulator.reset_hidden_state!","text":"reset_hidden_state!(model::DriverModel)\n\nResets the hidden states of the model. \n\n\n\n\n\n","category":"function"},{"location":"behaviors/#AutomotiveSimulator.reset_hidden_states!","page":"Behaviors","title":"AutomotiveSimulator.reset_hidden_states!","text":"reset_hidden_states!(models::Dict{I,M}) where {M<:DriverModel}\n\nreset hidden states of all driver models in models\n\n\n\n\n\n","category":"function"},{"location":"behaviors/#AutomotiveSimulator.observe!","page":"Behaviors","title":"AutomotiveSimulator.observe!","text":"observe!(model::DriverModel, scene, roadway, egoid)\n\nObserves the scene and updates the model states accordingly. \n\n\n\n\n\n","category":"function"},{"location":"behaviors/#Base.rand-Tuple{DriverModel}","page":"Behaviors","title":"Base.rand","text":"rand(model::DriverModel)\nrand(rng::AbstractRNG, model::DriverModel)\n\nSamples an action from the model.\n\n\n\n\n\n","category":"method"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"observe! and rand are usually the most important methods to implement. observe! sets the model state in a given situation and rand allows to sample an action from the model.","category":"page"},{"location":"behaviors/#Available-Behaviors-1","page":"Behaviors","title":"Available Behaviors","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    IntelligentDriverModel","category":"page"},{"location":"behaviors/#AutomotiveSimulator.IntelligentDriverModel","page":"Behaviors","title":"AutomotiveSimulator.IntelligentDriverModel","text":"IntelligentDriverModel <: LaneFollowingDriver\n\nThe Intelligent Driver Model. A rule based driving model that is governed by parameter settings. The output is an longitudinal acceleration.\n\nHere, we have extended IDM to the errorable IDM. If a standard deviation parameter is specified, then the output is a longitudinal acceleration sampled from a normal distribution around the non-errorable IDM output.\n\nFields\n\na::Float64 = NaN the predicted acceleration i.e. the output of the model\nσ::Float64 = NaN allows errorable IDM, optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk_spd::Float64 = 1.0 proportional constant for speed tracking when in freeflow [s⁻¹]\nδ::Float64 = 4.0 acceleration exponent\nT::Float64  = 1.5 desired time headway [s]\nv_des::Float64 = 29.0 desired speed [m/s]\ns_min::Float64 = 5.0 minimum acceptable gap [m]\na_max::Float64 = 3.0 maximum acceleration ability [m/s²]\nd_cmf::Float64 = 2.0 comfortable deceleration m/s²\nd_max::Float64 = 9.0 maximum deceleration m/s²\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    Tim2DDriver","category":"page"},{"location":"behaviors/#AutomotiveSimulator.Tim2DDriver","page":"Behaviors","title":"AutomotiveSimulator.Tim2DDriver","text":"Tim2DDriver\n\nDriver that combines longitudinal driver and lateral driver into one model.\n\nConstructors\n\nTim2DDriver(timestep::Float64;mlon::LaneFollowingDriver=IntelligentDriverModel(), mlat::LateralDriverModel=ProportionalLaneTracker(), mlane::LaneChangeModel=TimLaneChanger(timestep))\n\nFields\n\nmlon::LaneFollowingDriver = IntelligentDriverModel() Longitudinal driving model\nmlat::LateralDriverModel = ProportionalLaneTracker() Lateral driving model\nmlane::LaneChangeModel =TimLaneChanger Lane change model\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    PrincetonDriver","category":"page"},{"location":"behaviors/#AutomotiveSimulator.PrincetonDriver","page":"Behaviors","title":"AutomotiveSimulator.PrincetonDriver","text":"PrincetonDriver <: LaneFollowingDriver\n\nA lane following driver model that controls longitudinal speed by following a front car.\n\nFields\n\na::Float64\nσ::Float64 = NaN  optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    SidewalkPedestrianModel","category":"page"},{"location":"behaviors/#AutomotiveSimulator.SidewalkPedestrianModel","page":"Behaviors","title":"AutomotiveSimulator.SidewalkPedestrianModel","text":"SidewalkPedestrianModel\n\nWalks along the sidewalk until approaching the crosswalk. Waits for the cars to pass, then crosses.\n\nFields\n\ntimestep::Float64\nphase::Int = APPROACHING\nttc_threshold::Float64 = clamp(rand(Normal(4.0, 2.5)), 1.0, Inf)\ncrosswalk::Lane = Lane()\nsw_origin::Lane = Lane()\nsw_dest::Lane = Lane()\na::PedestrianLatLonAccel = PedestrianLatLonAccel(0.0, 0.0, sw_origin) makes you turn, left/right\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic\nv_des_approach::Float64 = clamp(rand(Normal(1.28, 0.18)), 0.0, Inf) Based on Feliciani et al. results\nv_des_appraise::Float64 = clamp(rand(Normal(0.94, 0.21)), 0.0, Inf)\nv_des_cross::Float64 = clamp(rand(Normal(1.35, 0.18)), 0.0, Inf)\nped_accel::Float64 = 0.30\nped_decel::Float64 = -0.50\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    StaticDriver","category":"page"},{"location":"behaviors/#AutomotiveSimulator.StaticDriver","page":"Behaviors","title":"AutomotiveSimulator.StaticDriver","text":"StaticDriver{A,P<:ContinuousMultivariateDistribution} <: DriverModel{A}\n\nA driver model where actions are always sampled by the same distribution specified  by the field distribution.\n\nFields\n\ndistribution::P\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Lane-change-helper-functions-1","page":"Behaviors","title":"Lane change helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used by the driver models to do lane changing and lateral control.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    MOBIL","category":"page"},{"location":"behaviors/#AutomotiveSimulator.MOBIL","page":"Behaviors","title":"AutomotiveSimulator.MOBIL","text":"MOBIL\n\nSee Treiber & Kesting, 'Modeling Lane-Changing Decisions with MOBIL'\n\nConstructor\n\nMOBIL(timestep::Float64;mlon::LaneFollowingDriver=IntelligentDriverModel(),safe_decel::Float64=2.0,       politeness::Float64=0.35,advantage_threshold::Float64=0.1)\n\nFields\n\ndir::Int\nmlon::LaneFollowingDriver=IntelligentDriverModel()\nsafe_decel::Float64=2.0\npoliteness::Float64=0.35\nadvantage_threshold::Float64=0.1\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    TimLaneChanger","category":"page"},{"location":"behaviors/#AutomotiveSimulator.TimLaneChanger","page":"Behaviors","title":"AutomotiveSimulator.TimLaneChanger","text":"TimLaneChanger\n\nA simple lane change behavior that changes lanes whenever the lead car is going slower than our desired speed. Lane changes are made when there is an available lane, fore/rear gaps exceed our thresholds, we are faster  than a rear vehicle in the target lane, and any lead vehicle in the target lane is faster than we can currently go.\n\nHas not been published anywhere, so first use in a paper would have to describe this. See MOBIL if you want a lane changer you can cite.\n\nConstructors\n\nTimLaneChanger(v_des::Float64=29.0, threshold_fore::Float64 = 50.0,threshold_lane_change_gap_fore::Float64 = 10.0, threshold_lane_change_gap_rear::Float64 = 10.0,dir::Int=DIR_MIDDLE)\n\nFields\n\ndir::Int = DIR_MIDDLE the desired lane to go to eg: left,middle (i.e. stay in same lane) or right\nv_des::Float64 = 29.0 desired velocity\nthreshold_fore::Float64 = 50.0 Distance from lead vehicle\nthreshold_lane_change_gap_fore::Float64 = 10.0 Space in front\nthreshold_lane_change_gap_rear::Float64 = 10.0 Space rear\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalLaneTracker","category":"page"},{"location":"behaviors/#AutomotiveSimulator.ProportionalLaneTracker","page":"Behaviors","title":"AutomotiveSimulator.ProportionalLaneTracker","text":"ProportionalLaneTracker\n\nA controller that executes the lane change decision made by the lane change models\n\nConstructors\n\nProportionalLaneTracker(;σ::Float64 = NaN,kp::Float64 = 3.0,kd::Float64 = 2.0)\n\nFields\n\na::Float64 = NaN predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nkp::Float64 = 3.0 proportional constant for lane tracking\nkd::Float64 = 2.0 derivative constant for lane tracking\n\n\n\n\n\n","category":"type"},{"location":"behaviors/#Longitudinal-helper-functions-1","page":"Behaviors","title":"Longitudinal helper functions","text":"","category":"section"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"These are not standalone driver models but are used to do longitudinal control by the driver models.","category":"page"},{"location":"behaviors/#","page":"Behaviors","title":"Behaviors","text":"    ProportionalSpeedTracker","category":"page"},{"location":"behaviors/#AutomotiveSimulator.ProportionalSpeedTracker","page":"Behaviors","title":"AutomotiveSimulator.ProportionalSpeedTracker","text":"ProportionalSpeedTracker <: LaneFollowingDriver\n\nLongitudinal proportional speed control.\n\nFields\n\na::Float64 = NaN  predicted acceleration\nσ::Float64 = NaN optional stdev on top of the model, set to zero or NaN for deterministic behavior\nk::Float64 = 1.0 proportional constant for speed tracking [s⁻¹]\nv_des::Float64 = 29.0  desired speed [m/s]\n\n\n\n\n\n","category":"type"},{"location":"actions/#Driving-Actions-1","page":"Driving Actions","title":"Driving Actions","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"In the driving stack, the actions lie one level below the behaviors. While the behaviors provide the high level decision making, the actions enable the execution of these decisions in the simulation.","category":"page"},{"location":"actions/#Interface-1","page":"Driving Actions","title":"Interface","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    propagate","category":"page"},{"location":"actions/#AutomotiveSimulator.propagate","page":"Driving Actions","title":"AutomotiveSimulator.propagate","text":"propagate(veh::Entity{S,D,I}, action::A, roadway::R, Δt::Float64) where {S,D,I,A,R}\n\nTake an entity of type {S,D,I} and move it over Δt seconds to produce a new entity based on the action on the given roadway.\n\n\n\n\n\nPropagate vehicle forward in time using a desired acceleration and turn rate\n\n\n\n\n\npropagate(veh::Entity{VehicleState,D,I}, action::AccelDesang, roadway::Roadway, Δt::Float64; n_integration_steps::Int=4) where {D,I}\n\nPropagate vehicle forward in time using a desired acceleration and heading angle\n\n\n\n\n\npropagate vehicle forward in time given a desired acceleration and steering angle. If steering angle higher than 0.1 radian, the vehicle drives in a circle\n\n\n\n\n\n","category":"function"},{"location":"actions/#Action-types-available-1","page":"Driving Actions","title":"Action types available","text":"","category":"section"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelDesang","category":"page"},{"location":"actions/#AutomotiveSimulator.AccelDesang","page":"Driving Actions","title":"AutomotiveSimulator.AccelDesang","text":"AccelDesang\n\nAn action type with a longitudinal acceleration and a desired heading angle\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nϕdes::Float64 desired heading angle\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelSteeringAngle","category":"page"},{"location":"actions/#AutomotiveSimulator.AccelSteeringAngle","page":"Driving Actions","title":"AutomotiveSimulator.AccelSteeringAngle","text":"AccelSteeringAngle\n\nAllows driving the car in a circle based on the steering angle If steering angle less than threshold 0.01 radian, just drives straight\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nδ::Float64 Steering angle [rad]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    AccelTurnrate","category":"page"},{"location":"actions/#AutomotiveSimulator.AccelTurnrate","page":"Driving Actions","title":"AutomotiveSimulator.AccelTurnrate","text":"AccelTurnrate\n\nAn action type with a longitudinal acceleration and a turn rate\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\nω::Float64 desired turn rate [rad/sec]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LaneFollowingAccel","category":"page"},{"location":"actions/#AutomotiveSimulator.LaneFollowingAccel","page":"Driving Actions","title":"AutomotiveSimulator.LaneFollowingAccel","text":"LaneFollowingAccel\n\nLongitudinal acceleration. The resulting vehicle velocity is capped below at 0 (i.e. standstill). Negative velocities are not allowed.\n\nFields\n\na::Float64 longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    LatLonAccel","category":"page"},{"location":"actions/#AutomotiveSimulator.LatLonAccel","page":"Driving Actions","title":"AutomotiveSimulator.LatLonAccel","text":"LatLonAccel\n\nAcceleration in the frenet frame\n\nFields\n\na_lat::Float64 Lateral acceleration [m/s^2]\na_lon::Float64 Longitudinal acceleration [m/s^2]\n\n\n\n\n\n","category":"type"},{"location":"actions/#","page":"Driving Actions","title":"Driving Actions","text":"    PedestrianLatLonAccel","category":"page"},{"location":"actions/#AutomotiveSimulator.PedestrianLatLonAccel","page":"Driving Actions","title":"AutomotiveSimulator.PedestrianLatLonAccel","text":"PedestrianLatLonAccel\n\nPedestrian walking action. Acceleration in the Frenet frame, along with desired lane after crossing the street.\n\nFields\n\na_lat::Float64 lateral acceleration [m/s^2]\na_lon::Float64 longitudinal accelaration [m/s^2]\nlane_des::Lane desired lane to move to\n\n\n\n\n\n","category":"type"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"EditURL = \"https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/sidewalk.jl\"","category":"page"},{"location":"tutorials/sidewalk/#Sidewalk-1","page":"Sidewalk","title":"Sidewalk","text":"","category":"section"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"(Image: )","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"In this notebook, we will be creating a sidewalk environment in which  pedestrians can walk along the sidewalk and cross the street as cars pass.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Parameters\nusing AutomotiveSimulator\nusing AutomotiveVisualization\nAutomotiveVisualization.colortheme[\"background\"] = colorant\"white\"; # hide\nusing Cairo","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Define sidewalk IDs","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"const TOP = 1\nconst BOTTOM = 2\nnothing # hide","category":"page"},{"location":"tutorials/sidewalk/#Creating-the-Environment-1","page":"Sidewalk","title":"Creating the Environment","text":"","category":"section"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Here, we create a new type of environment called SidewalkEnv. It consists of a roadway, crosswalk, and sidewalk. A sidewalk is a Vector of Lanes that run alongside the road.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"@with_kw mutable struct SidewalkEnv\n    roadway::Roadway\n    crosswalk::Lane\n    sidewalk::Vector{Lane}\nend;\nnothing # hide","category":"page"},{"location":"tutorials/sidewalk/#Defining-the-Sidewalk-1","page":"Sidewalk","title":"Defining the Sidewalk","text":"","category":"section"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We define the sidewalk's parameters.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"# Geometry parameters\nroadway_length = 100.\ncrosswalk_length = 15.\ncrosswalk_width = 6.0\ncrosswalk_pos = roadway_length/2\nsidewalk_width = 3.0\nsidewalk_pos = crosswalk_length/2 - sidewalk_width / 2\nnothing # hide","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Now we create the sidewalk environment. Our environment will consist of:","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"1-way road with 2 lanes\nUnsignalized zebra crosswalk perpendicular to the road\nSidewalks above and below the road","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Generate straight roadway of length roadway_length with 2 lanes. Returns a Roadway type (Array of segments). There is already a method to generate a simple straight roadway, which we use here.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"roadway = gen_straight_roadway(2, roadway_length)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Generate the crosswalk. Our crosswalk does not have a predefined method for generation, so we define it with a LaneTag and a curve.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"n_samples = 2 # for curve generation\ncrosswalk = Lane(LaneTag(2,1), gen_straight_curve(VecE2(crosswalk_pos, -crosswalk_length/2),\n                                                  VecE2(crosswalk_pos, crosswalk_length/2),\n                                                   n_samples), width = crosswalk_width)\ncw_segment = RoadSegment(2, [crosswalk])\npush!(roadway.segments, cw_segment) # Append the crosswalk to the roadway\n\n# Generate the sidewalk\ntop_sidewalk = Lane(LaneTag(3, TOP), gen_straight_curve(VecE2(0., sidewalk_pos),\n                                                      VecE2(roadway_length, sidewalk_pos),\n                                                        n_samples), width = sidewalk_width)\nbottom_sidewalk = Lane(LaneTag(3, BOTTOM), gen_straight_curve(VecE2(0., -(sidewalk_pos - sidewalk_width)),\n                                                          VecE2(roadway_length, -(sidewalk_pos - sidewalk_width)),\n                                                            n_samples), width = sidewalk_width)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Note: we subtract the sidewalk_width from the sidewalk position so that the edge is flush with the road.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"sw_segment = RoadSegment(3, [top_sidewalk, bottom_sidewalk])\npush!(roadway.segments, sw_segment)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Initialize crosswalk environment","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"env = SidewalkEnv(roadway, crosswalk, [top_sidewalk, bottom_sidewalk]);\nnothing # hide","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Since there is no defined add_renderable! method for the crosswalk and the sidewalk, we must define it ourselves.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"function AutomotiveVisualization.add_renderable!(rendermodel::RenderModel, env::SidewalkEnv)\n    # Render sidewalk\n    for sw in env.sidewalk\n        curve = sw.curve\n        n = length(curve)\n        pts = Array{Float64}(undef, 2, n)\n        for (i,pt) in enumerate(curve)\n            pts[1,i] = pt.pos.x\n            pts[2,i] = pt.pos.y\n        end\n        add_instruction!(rendermodel, render_line, (pts, colorant\"grey\", sw.width, Cairo.CAIRO_LINE_CAP_BUTT))\n    end\n\n    # Render roadway\n    roadway = gen_straight_roadway(2, roadway_length)\n    add_renderable!(rendermodel, roadway)\n\n    # Render crosswalk\n    curve = env.crosswalk.curve\n    n = length(curve)\n    pts = Array{Float64}(undef, 2, n)\n    for (i,pt) in enumerate(curve)\n        pts[1,i] = pt.pos.x\n        pts[2,i] = pt.pos.y\n    end\n\n    # We can add render instructions from AutomotiveVisualization.\n    # Here we want the crosswalk to appear as a white-striped zebra crossing rather than a road.\n    add_instruction!(rendermodel, render_dashed_line, (pts, colorant\"white\", env.crosswalk.width, 1.0, 1.0, 0.0, Cairo.CAIRO_LINE_CAP_BUTT))\n\n    return rendermodel\nend\n\nsnapshot = render([env])\nwrite(\"sidewalk.svg\", snapshot) # hide","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"(Image: sidewalk)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Now we can define our pedestrian.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We define its class and the dimensions of its bounding box.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"const PEDESTRIAN_DEF = VehicleDef(AgentClass.PEDESTRIAN, 1.0, 1.0)\nnothing # hide","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We assign models to each agent in the scene.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"timestep = 0.1","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Crossing pedestrian definition","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"ped_init_state = VehicleState(VecSE2(49.0,-3.0,0.), env.sidewalk[BOTTOM], roadway, 1.3)\nped = Entity(ped_init_state, PEDESTRIAN_DEF, :pedestrian)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Car definition","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"car_initial_state = VehicleState(VecSE2(0.0, 0., 0.), roadway.segments[1].lanes[1],roadway, 8.0)\ncar = Entity(car_initial_state, VehicleDef(), :car)\n\nscene = Scene([ped, car])","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Define a model for each entity present in the scene","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"models = Dict{Symbol, DriverModel}(\n    :pedestrian => SidewalkPedestrianModel(\n        timestep=timestep, crosswalk=env.crosswalk,\n        sw_origin = env.sidewalk[BOTTOM], sw_dest = env.sidewalk[TOP]\n    ),\n    :car        => LatLonSeparableDriver( # produces LatLonAccels\n        ProportionalLaneTracker(), # lateral model\n        IntelligentDriverModel(), # longitudinal model\n    )\n)\nnothing # hide\n\n### Simulate","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"Finally, we simulate and visualize the scene.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Reel\n\nnticks = 300\nscenes = simulate(scene, roadway, models, nticks, timestep)\n\nanimation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt\n    i = Int(floor(t/dt)) + 1\n    render([env, scenes[i]])\nend;\n\nwrite(\"sidewalk_animation.gif\", animation); # hide\nnothing #hide","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"(Image: sidewalk animation)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"We can use a slider to scroll through each scene in the simulation. This usually takes less time than rendering a video.","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"using Interact\nusing Reel\nusing Blink\n#md\nw = Window()\nviz = @manipulate for i in 1 : length(scenes)\n    render([env, scenes[i]])\nend\nbody!(w, viz)","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"","category":"page"},{"location":"tutorials/sidewalk/#","page":"Sidewalk","title":"Sidewalk","text":"This page was generated using Literate.jl.","category":"page"},{"location":"states/#States-1","page":"States","title":"States","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"In this section of the documentation we explain the default vehicle state type provided by AutomotiveSimulator as well as the data types used to represent a driving scene. Most of the underlying structures are defined in Records.jl.  The data structures provided in ADM.jl are concrete instances of parametric types defined in Records. It is possible in principle to define your custom state definition and use the interface defined in ADM.jl.","category":"page"},{"location":"states/#Entity-state-1","page":"States","title":"Entity state","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Entities are represented by the Entity data type. The Entity data type has three fields: a state, a definition and an id. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    Entity","category":"page"},{"location":"states/#AutomotiveSimulator.Entity","page":"States","title":"AutomotiveSimulator.Entity","text":"Entity{S,D,I}\n\nImmutable data structure to represent entities (vehicle, pedestrian, ...).  Entities are defined by a state, a definition, and an id.  The state of an entity usually models changing values while the definition and the id should not change. \n\nConstructor\n\nEntity(state, definition, id)\n\nCopy constructor that keeps the definition and id but changes the state (a new object is still created):\n\nEntity(entity::Entity{S,D,I}, s::S)\n\nFields\n\nstate::S\ndef::D\nid::I\n\n\n\n\n\n","category":"type"},{"location":"states/#","page":"States","title":"States","text":"The state of an entity usually describes physical quantity such as position and velocity. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"Two state data structures are provided.","category":"page"},{"location":"states/#Scenes-1","page":"States","title":"Scenes","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Scenes are represented using the Scene object. It is a datastructure to represent a collection of entities. ","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    Scene ","category":"page"},{"location":"states/#AutomotiveSimulator.Scene","page":"States","title":"AutomotiveSimulator.Scene","text":"Scene{E}\n\nContainer to store a list of entities.  The main difference from a regular array is that its size is defined at construction and is fixed. (push! is O(1))\n\nConstructors\n\nScene(arr::AbstractVector; capacity::Int=length(arr))\nScene(::Type{E}, capacity::Int=100) where {E}\n\nFields\n\nTo interact with Scene object it is preferable to use functions rather than accessing the fields directly.\n\nentities::Vector{E}\nn::Int current number of entities in the scene\n\n\n\n\n\n","category":"type"},{"location":"states/#Defining-your-own-state-type-1","page":"States","title":"Defining your own state type","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"You can define your own state type if the provided VehicleState does not contain the right information. There are a of couple functions that need to be defined such that other functions in AutomotiveSimulator can work smoothly with your custom state type.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    posg\n    posf\n    vel\n    velf\n    velg","category":"page"},{"location":"states/#AutomotiveSimulator.posg","page":"States","title":"AutomotiveSimulator.posg","text":"posg(state)\n\nreturns the coordinates of the state in the global (world) frame. The return type is expected to be a VecSE2.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.posf","page":"States","title":"AutomotiveSimulator.posf","text":"posf(state)\n\nreturns the coordinates of the state in the Frenet frame.  The return type is expected to be Frenet.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.vel","page":"States","title":"AutomotiveSimulator.vel","text":"vel(state)\n\nreturns the norm of the longitudinal velocity.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.velf","page":"States","title":"AutomotiveSimulator.velf","text":"velf(state)\n\nreturns the velocity of the state in the Frenet frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.velg","page":"States","title":"AutomotiveSimulator.velg","text":"velg(state)\n\nreturns the velocity of the state in the global (world) frame.\n\n\n\n\n\n","category":"function"},{"location":"states/#","page":"States","title":"States","text":"Example of a custom state type containing acceleration:","category":"page"},{"location":"states/#","page":"States","title":"States","text":"\n# you can use composition to define your custom state type based on existing ones\nstruct MyVehicleState\n    veh::VehicleState\n    acc::Float64\nend\n\n# define the functions from the interface \nposg(s::MyVehicleState) = posg(s.veh) # those functions are implemented for the `VehicleState` type\nposf(s::MyVehicleState) = posf(s.veh)\nvelg(s::MyVehicleState) = velg(s.veh)\nvelf(s::MyVehicleState) = velf(s.veh)\nvel(s::MyVehicleState) = vel(s.veh)","category":"page"},{"location":"states/#Provided-State-Type-and-Convenient-Functions-1","page":"States","title":"Provided State Type and Convenient Functions","text":"","category":"section"},{"location":"states/#","page":"States","title":"States","text":"Here we list useful functions to interact with vehicle states and retrieve interesting information like the position of the front of the vehicle or the lane to which the vehicle belongs.","category":"page"},{"location":"states/#","page":"States","title":"States","text":"    VehicleState\n    Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n    move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64; ϕ₂::Float64=vehstate.posF.ϕ, ::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n    get_front\n    get_rear\n    get_center\n    get_footpoint\n    get_lane\n    leftlane(::Roadway, ::Entity)\n    rightlane(::Roadway, ::Entity)\n    Base.convert(::Type{Entity{S, VehicleDef, I}}, veh::Entity{S, D, I}) where {S,D<:AbstractAgentDefinition,I}","category":"page"},{"location":"states/#AutomotiveSimulator.VehicleState","page":"States","title":"AutomotiveSimulator.VehicleState","text":"VehicleState\n\nA default type to represent an agent physical state (position, velocity). It contains the position in the global frame, Frenet frame and the longitudinal velocity\n\nconstructors\n\nVehicleState(posG::VecSE2{Float64}, v::Float64) \nVehicleState(posG::VecSE2{Float64}, roadway::Roadway, v::Float64)\nVehicleState(posG::VecSE2{Float64}, lane::Lane, roadway::Roadway, v::Float64)\nVehicleState(posF::Frenet, roadway::Roadway, v::Float64)\n\nfields\n\nposG::VecSE2{Float64} global position\nposF::Frenet lane relative position\nv::Float64 longitudinal velocity\n\n\n\n\n\n","category":"type"},{"location":"states/#AutomotiveSimulator.Vec.lerp-Tuple{VehicleState,VehicleState,Float64,Roadway}","page":"States","title":"AutomotiveSimulator.Vec.lerp","text":"Vec.lerp(a::VehicleState, b::VehicleState, t::Float64, roadway::Roadway)\n\nPerform linear interpolation of the two vehicle states. Returns a VehicleState.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveSimulator.move_along-Tuple{VehicleState,Roadway,Float64}","page":"States","title":"AutomotiveSimulator.move_along","text":"move_along(vehstate::VehicleState, roadway::Roadway, Δs::Float64;\nϕ₂::Float64=vehstate.posF.ϕ, t₂::Float64=vehstate.posF.t, v₂::Float64=vehstate.v)\n\nreturns a vehicle state after moving vehstate of a length Δs along its lane.\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveSimulator.get_front","page":"States","title":"AutomotiveSimulator.get_front","text":"get_front(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the front of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.get_rear","page":"States","title":"AutomotiveSimulator.get_rear","text":"get_rear(veh::Entity{VehicleState, VehicleDef, I})\n\nreturns the position of the rear of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.get_center","page":"States","title":"AutomotiveSimulator.get_center","text":"get_center(veh::Entity{VehicleState, D, I})\n\nreturns the position of the center of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.get_footpoint","page":"States","title":"AutomotiveSimulator.get_footpoint","text":"get_footpoint(veh::Entity{VehicleState, D, I})\n\nreturns the position of the footpoint of the vehicle\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.get_lane","page":"States","title":"AutomotiveSimulator.get_lane","text":"get_lane(roadway::Roadway, vehicle::Entity)\nget_lane(roadway::Roadway, vehicle::VehicleState)\n\nreturn the lane where vehicle is in.\n\n\n\n\n\n","category":"function"},{"location":"states/#AutomotiveSimulator.leftlane-Tuple{Roadway,Entity}","page":"States","title":"AutomotiveSimulator.leftlane","text":"leftlane(roadway::Roadway, veh::Entity)\n\nreturns the lane to the left of the lane veh is currently in, returns nothing if it does not exists\n\n\n\n\n\n","category":"method"},{"location":"states/#AutomotiveSimulator.rightlane-Tuple{Roadway,Entity}","page":"States","title":"AutomotiveSimulator.rightlane","text":"rightlane(roadway::Roadway, veh::Entity)\n\nreturns the lane to the right of the lane veh is currently in, returns nothing if it does not exists\n\n\n\n\n\n","category":"method"},{"location":"states/#Base.convert-Union{Tuple{I}, Tuple{D}, Tuple{S}, Tuple{Type{Entity{S,VehicleDef,I}},Entity{S,D,I}}} where I where D<:AbstractAgentDefinition where S","page":"States","title":"Base.convert","text":"Base.convert(::Type{Entity{S, VehicleDef, I}}, veh::Entity{S, D, I}) where {S,D<:AbstractAgentDefinition,I}\n\nConverts the definition of an entity\n\n\n\n\n\n","category":"method"},{"location":"#AutomotiveSimulator-1","page":"Home","title":"AutomotiveSimulator","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This is the documentation for AutomotiveSimulator.jl. ","category":"page"},{"location":"#Concepts-1","page":"Home","title":"Concepts","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"This section defines a few terms that are used across the package. ","category":"page"},{"location":"#Entity-1","page":"Home","title":"Entity","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"An entity (or sometimes called agent) is a traffic participant that navigates in the environment, it is defined by a physical state (position, velocity, ...), an agent definition (whether it is a car or pedestrian, how large it is, ...), and an ID.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"AutomotiveSimulator is templated to efficiently run simulations with different types of entities. An entity represents an agent in the simulation, and it is parameterized by","category":"page"},{"location":"#","page":"Home","title":"Home","text":"S: state of the entity, may change over time\nD: definition of the entity, does not change over time\nI: unique identifier for the entity, typically an Int64 or Symbol","category":"page"},{"location":"#","page":"Home","title":"Home","text":"The interface for implementing your own state type is described in States.  Similarly, an interface for implementing your own entity definition is described in Agent Definition","category":"page"},{"location":"#","page":"Home","title":"Home","text":"In addition to the state, definition and identifier for each simulation agent, one can also customize the actions, environment and the driver models used by the agents.","category":"page"},{"location":"#Actions-1","page":"Home","title":"Actions","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"An action consists of a command applied to move the entity (e.g. longitudinal acceleration, steering). The state of the entity is updated using the propagate method which encodes the dynamics model.","category":"page"},{"location":"#Scene-1","page":"Home","title":"Scene","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A scene represents a snapshot in time of a driving situation, it essentially consists of a list of entities at a given time.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"It is implemented using the Scene object. Scene supports most of the operation that one can do on a collection (iterate, in, push!, ...).  In addition it supports get_by_id to retrieve an entity by its ID.","category":"page"},{"location":"#Driver-Model-1","page":"Home","title":"Driver Model","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A driver model is a distribution over actions. Given a scene, each entity can update its model, we call this process observation (the corresponding method is observe!). After observing the scene, an action can be sampled from the driver model (using rand).","category":"page"},{"location":"#Tutorials-1","page":"Home","title":"Tutorials","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"The following examples will showcase some of the simulation functionality of AutomotiveSimulator","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Driving on a Straight Roadway\nDriving in a Stadium\nIntersection\nCrosswalk\nSidewalk\nFeature Extraction","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nAll AutomotiveSimulator tutorials are available as Jupyter notebooks by clicking on the badge at the beginning of the tutorial!","category":"page"}]
}
