<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Intersection · AutomotiveSimulator.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">AutomotiveSimulator.jl</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../straight_roadway/">Driving on a Straight Roadway</a></li><li><a class="tocitem" href="../stadium/">Driving in a Stadium</a></li><li class="is-active"><a class="tocitem" href>Intersection</a><ul class="internal"><li><a class="tocitem" href="#Generate-a-T-Shape-intersection-1"><span>Generate a T-Shape intersection</span></a></li><li><a class="tocitem" href="#Navigation-in-the-new-road-network-1"><span>Navigation in the new road network</span></a></li></ul></li><li><a class="tocitem" href="../crosswalk/">Crosswalk</a></li><li><a class="tocitem" href="../sidewalk/">Sidewalk</a></li><li><a class="tocitem" href="../feature_extraction/">Feature Extraction</a></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../Roadways/">Roadways</a></li><li><a class="tocitem" href="../../actions/">Driving Actions</a></li><li><a class="tocitem" href="../../states/">States</a></li><li><a class="tocitem" href="../../agent_definitions/">Agent Definition</a></li><li><a class="tocitem" href="../../behaviors/">Behaviors</a></li><li><a class="tocitem" href="../../simulation/">Simulation</a></li><li><a class="tocitem" href="../../collision_checkers/">Collision Checker</a></li><li><a class="tocitem" href="../../feature_extraction/">Feature Extraction</a></li></ul></li><li><span class="tocitem">Internals</span><ul><li><a class="tocitem" href="../../Vec/">Vec</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Intersection</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Intersection</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/sisl/AutomotiveSimulator.jl/blob/master/docs/lit/tutorials/intersection.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Intersection-1"><a class="docs-heading-anchor" href="#Intersection-1">Intersection</a><a class="docs-heading-anchor-permalink" href="#Intersection-1" title="Permalink"></a></h1><p><a href="https://nbviewer.jupyter.org/github/sisl/AutomotiveSimulator.jl/blob/gh-pages/v0.1.1/notebooks/intersection.ipynb"><img src="https://img.shields.io/badge/show-nbviewer-579ACA.svg" alt/></a></p><p>In this example we demonstrate how to define a T-shape intersection with <code>AutomotiveSimulator</code>. You will also learn how to define your own custom action type and driver model type.</p><h2 id="Generate-a-T-Shape-intersection-1"><a class="docs-heading-anchor" href="#Generate-a-T-Shape-intersection-1">Generate a T-Shape intersection</a><a class="docs-heading-anchor-permalink" href="#Generate-a-T-Shape-intersection-1" title="Permalink"></a></h2><p>In order to generate the road network, we first initialize a Roadway object.</p><pre><code class="language-julia">using AutomotiveSimulator
using AutomotiveVisualization
using Random

roadway = Roadway()</code></pre><p>Define coordinates of the entry and exit points to the intersection</p><pre><code class="language-julia">r = 5.0 # turn radius
w = DEFAULT_LANE_WIDTH

A = VecSE2(0.0,w,-π)
B = VecSE2(0.0,0.0,0.0)
C = VecSE2(r,-r,-π/2)
D = VecSE2(r+w,-r,π/2)
E = VecSE2(2r+w,0,0)
F = VecSE2(2r+w,w,-π)</code></pre><p>The next step consists in appending all the lanes to the road network. We can define a helper function to add a new lane to the roadway.</p><pre><code class="language-julia">function append_to_curve!(target::Curve, newstuff::Curve)
    s_end = target[end].s
    for c in newstuff
        push!(target, CurvePt(c.pos, c.s+s_end, c.k, c.kd))
    end
    return target
end</code></pre><p>Example of a lane that consists of 3 road segments, a straight curve (from the left to the center), a turning part (right turn) and a final straight curve.</p><p>Append right turn coming from the left</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)
append_to_curve!(curve, gen_bezier_curve(B, C, 0.6r, 0.6r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50.0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))</code></pre><pre><code class="language-none">1-element Array{RoadSegment{Float64},1}:
 RoadSegment{Float64}(1, Lane{Float64}[Lane{Float64}(LaneTag(1, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({0.179, -0.002, -0.027}, 100.179, -0.153, NaN), CurvePt({0.355, -0.010, -0.054}, 100.355, -0.157, NaN), CurvePt({0.529, -0.021, -0.082}, 100.530, -0.162, NaN), CurvePt({0.700, -0.038, -0.110}, 100.702, -0.166, NaN), CurvePt({0.869, -0.059, -0.139}, 100.872, -0.171, NaN), CurvePt({1.035, -0.085, -0.168}, 101.040, -0.175, NaN), CurvePt({1.198, -0.115, -0.198}, 101.206, -0.180, NaN), CurvePt({1.359, -0.150, -0.227}, 101.370, -0.184, NaN)  …  CurvePt({4.885, -3.802, -1.373}, 106.755, -0.180, NaN), CurvePt({4.915, -3.965, -1.403}, 106.921, -0.175, NaN), CurvePt({4.941, -4.131, -1.432}, 107.089, -0.171, NaN), CurvePt({4.962, -4.300, -1.461}, 107.259, -0.166, NaN), CurvePt({4.979, -4.471, -1.489}, 107.431, -0.162, NaN), CurvePt({4.990, -4.645, -1.517}, 107.605, -0.157, NaN), CurvePt({4.998, -4.821, -1.544}, 107.782, -0.153, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, -0.148, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 157.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])</code></pre><p>visualize the current lane constellation</p><pre><code class="language-julia">snapshot = render([roadway])</code></pre><p><img src="../partial_intersection.svg" alt="partial intersection"/></p><p>Let&#39;s repeat the process and complete the T-shape intersection</p><p>Append straight left</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, B+VecE2(-100,0)), convert(VecE2, B), 2)
append_to_curve!(curve, gen_straight_curve(convert(VecE2, B), convert(VecE2, E), 2)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))</code></pre><pre><code class="language-none">2-element Array{RoadSegment{Float64},1}:
 RoadSegment{Float64}(1, Lane{Float64}[Lane{Float64}(LaneTag(1, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({0.179, -0.002, -0.027}, 100.179, -0.153, NaN), CurvePt({0.355, -0.010, -0.054}, 100.355, -0.157, NaN), CurvePt({0.529, -0.021, -0.082}, 100.530, -0.162, NaN), CurvePt({0.700, -0.038, -0.110}, 100.702, -0.166, NaN), CurvePt({0.869, -0.059, -0.139}, 100.872, -0.171, NaN), CurvePt({1.035, -0.085, -0.168}, 101.040, -0.175, NaN), CurvePt({1.198, -0.115, -0.198}, 101.206, -0.180, NaN), CurvePt({1.359, -0.150, -0.227}, 101.370, -0.184, NaN)  …  CurvePt({4.885, -3.802, -1.373}, 106.755, -0.180, NaN), CurvePt({4.915, -3.965, -1.403}, 106.921, -0.175, NaN), CurvePt({4.941, -4.131, -1.432}, 107.089, -0.171, NaN), CurvePt({4.962, -4.300, -1.461}, 107.259, -0.166, NaN), CurvePt({4.979, -4.471, -1.489}, 107.431, -0.162, NaN), CurvePt({4.990, -4.645, -1.517}, 107.605, -0.157, NaN), CurvePt({4.998, -4.821, -1.544}, 107.782, -0.153, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, -0.148, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 157.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(2, Lane{Float64}[Lane{Float64}(LaneTag(2, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({63.000, 0.000, 0.000}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])</code></pre><p>Append straight right</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)
append_to_curve!(curve, gen_straight_curve(convert(VecE2, F), convert(VecE2, A), 2)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))</code></pre><pre><code class="language-none">3-element Array{RoadSegment{Float64},1}:
 RoadSegment{Float64}(1, Lane{Float64}[Lane{Float64}(LaneTag(1, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({0.179, -0.002, -0.027}, 100.179, -0.153, NaN), CurvePt({0.355, -0.010, -0.054}, 100.355, -0.157, NaN), CurvePt({0.529, -0.021, -0.082}, 100.530, -0.162, NaN), CurvePt({0.700, -0.038, -0.110}, 100.702, -0.166, NaN), CurvePt({0.869, -0.059, -0.139}, 100.872, -0.171, NaN), CurvePt({1.035, -0.085, -0.168}, 101.040, -0.175, NaN), CurvePt({1.198, -0.115, -0.198}, 101.206, -0.180, NaN), CurvePt({1.359, -0.150, -0.227}, 101.370, -0.184, NaN)  …  CurvePt({4.885, -3.802, -1.373}, 106.755, -0.180, NaN), CurvePt({4.915, -3.965, -1.403}, 106.921, -0.175, NaN), CurvePt({4.941, -4.131, -1.432}, 107.089, -0.171, NaN), CurvePt({4.962, -4.300, -1.461}, 107.259, -0.166, NaN), CurvePt({4.979, -4.471, -1.489}, 107.431, -0.162, NaN), CurvePt({4.990, -4.645, -1.517}, 107.605, -0.157, NaN), CurvePt({4.998, -4.821, -1.544}, 107.782, -0.153, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, -0.148, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 157.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(2, Lane{Float64}[Lane{Float64}(LaneTag(2, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({63.000, 0.000, 0.000}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(3, Lane{Float64}[Lane{Float64}(LaneTag(3, 1), CurvePt{Float64}[CurvePt({63.000, 3.000, 3.142}, 0.000, 0.000, NaN), CurvePt({13.000, 3.000, 3.142}, 50.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({-100.000, 3.000, 3.142}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])</code></pre><p>Append left turn coming from the right</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, F+VecE2(50,0)), convert(VecE2, F), 2)
append_to_curve!(curve, gen_bezier_curve(F, C, 0.9r, 0.9r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, C), convert(VecE2, C+VecE2(0,-50)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))</code></pre><pre><code class="language-none">4-element Array{RoadSegment{Float64},1}:
 RoadSegment{Float64}(1, Lane{Float64}[Lane{Float64}(LaneTag(1, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({0.179, -0.002, -0.027}, 100.179, -0.153, NaN), CurvePt({0.355, -0.010, -0.054}, 100.355, -0.157, NaN), CurvePt({0.529, -0.021, -0.082}, 100.530, -0.162, NaN), CurvePt({0.700, -0.038, -0.110}, 100.702, -0.166, NaN), CurvePt({0.869, -0.059, -0.139}, 100.872, -0.171, NaN), CurvePt({1.035, -0.085, -0.168}, 101.040, -0.175, NaN), CurvePt({1.198, -0.115, -0.198}, 101.206, -0.180, NaN), CurvePt({1.359, -0.150, -0.227}, 101.370, -0.184, NaN)  …  CurvePt({4.885, -3.802, -1.373}, 106.755, -0.180, NaN), CurvePt({4.915, -3.965, -1.403}, 106.921, -0.175, NaN), CurvePt({4.941, -4.131, -1.432}, 107.089, -0.171, NaN), CurvePt({4.962, -4.300, -1.461}, 107.259, -0.166, NaN), CurvePt({4.979, -4.471, -1.489}, 107.431, -0.162, NaN), CurvePt({4.990, -4.645, -1.517}, 107.605, -0.157, NaN), CurvePt({4.998, -4.821, -1.544}, 107.782, -0.153, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, -0.148, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 157.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(2, Lane{Float64}[Lane{Float64}(LaneTag(2, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({63.000, 0.000, 0.000}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(3, Lane{Float64}[Lane{Float64}(LaneTag(3, 1), CurvePt{Float64}[CurvePt({63.000, 3.000, 3.142}, 0.000, 0.000, NaN), CurvePt({13.000, 3.000, 3.142}, 50.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({-100.000, 3.000, 3.142}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(4, Lane{Float64}[Lane{Float64}(LaneTag(4, 1), CurvePt{Float64}[CurvePt({63.000, 3.000, 3.142}, 0.000, 0.000, NaN), CurvePt({13.000, 3.000, 3.142}, 50.000, 0.000, NaN), CurvePt({12.731, 2.996, -3.110}, 50.269, 0.117, NaN), CurvePt({12.465, 2.983, -3.079}, 50.535, 0.118, NaN), CurvePt({12.201, 2.963, -3.048}, 50.800, 0.119, NaN), CurvePt({11.940, 2.934, -3.016}, 51.062, 0.120, NaN), CurvePt({11.683, 2.898, -2.985}, 51.323, 0.121, NaN), CurvePt({11.428, 2.853, -2.954}, 51.582, 0.122, NaN), CurvePt({11.176, 2.801, -2.922}, 51.839, 0.123, NaN), CurvePt({10.927, 2.741, -2.890}, 52.094, 0.124, NaN)  …  CurvePt({5.199, -3.176, -1.790}, 60.764, 0.123, NaN), CurvePt({5.147, -3.428, -1.759}, 61.022, 0.122, NaN), CurvePt({5.103, -3.683, -1.727}, 61.280, 0.121, NaN), CurvePt({5.066, -3.940, -1.696}, 61.541, 0.120, NaN), CurvePt({5.037, -4.201, -1.665}, 61.803, 0.119, NaN), CurvePt({5.017, -4.465, -1.633}, 62.068, 0.118, NaN), CurvePt({5.004, -4.731, -1.602}, 62.334, 0.117, NaN), CurvePt({5.000, -5.000, -1.571}, 62.603, 0.115, NaN), CurvePt({5.000, -5.000, -1.571}, 62.603, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 112.603, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])</code></pre><p>Append right turn coming from below</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)
append_to_curve!(curve, gen_bezier_curve(D, E, 0.6r, 0.6r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, E), convert(VecE2, E+VecE2(50,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))</code></pre><pre><code class="language-none">5-element Array{RoadSegment{Float64},1}:
 RoadSegment{Float64}(1, Lane{Float64}[Lane{Float64}(LaneTag(1, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({0.179, -0.002, -0.027}, 100.179, -0.153, NaN), CurvePt({0.355, -0.010, -0.054}, 100.355, -0.157, NaN), CurvePt({0.529, -0.021, -0.082}, 100.530, -0.162, NaN), CurvePt({0.700, -0.038, -0.110}, 100.702, -0.166, NaN), CurvePt({0.869, -0.059, -0.139}, 100.872, -0.171, NaN), CurvePt({1.035, -0.085, -0.168}, 101.040, -0.175, NaN), CurvePt({1.198, -0.115, -0.198}, 101.206, -0.180, NaN), CurvePt({1.359, -0.150, -0.227}, 101.370, -0.184, NaN)  …  CurvePt({4.885, -3.802, -1.373}, 106.755, -0.180, NaN), CurvePt({4.915, -3.965, -1.403}, 106.921, -0.175, NaN), CurvePt({4.941, -4.131, -1.432}, 107.089, -0.171, NaN), CurvePt({4.962, -4.300, -1.461}, 107.259, -0.166, NaN), CurvePt({4.979, -4.471, -1.489}, 107.431, -0.162, NaN), CurvePt({4.990, -4.645, -1.517}, 107.605, -0.157, NaN), CurvePt({4.998, -4.821, -1.544}, 107.782, -0.153, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, -0.148, NaN), CurvePt({5.000, -5.000, -1.571}, 107.961, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 157.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(2, Lane{Float64}[Lane{Float64}(LaneTag(2, 1), CurvePt{Float64}[CurvePt({-100.000, 0.000, 0.000}, 0.000, 0.000, NaN), CurvePt({0.000, 0.000, 0.000}, 100.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({13.000, 0.000, 0.000}, 113.000, 0.000, NaN), CurvePt({63.000, 0.000, 0.000}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(3, Lane{Float64}[Lane{Float64}(LaneTag(3, 1), CurvePt{Float64}[CurvePt({63.000, 3.000, 3.142}, 0.000, 0.000, NaN), CurvePt({13.000, 3.000, 3.142}, 50.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({0.000, 3.000, 3.142}, 63.000, 0.000, NaN), CurvePt({-100.000, 3.000, 3.142}, 163.000, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(4, Lane{Float64}[Lane{Float64}(LaneTag(4, 1), CurvePt{Float64}[CurvePt({63.000, 3.000, 3.142}, 0.000, 0.000, NaN), CurvePt({13.000, 3.000, 3.142}, 50.000, 0.000, NaN), CurvePt({12.731, 2.996, -3.110}, 50.269, 0.117, NaN), CurvePt({12.465, 2.983, -3.079}, 50.535, 0.118, NaN), CurvePt({12.201, 2.963, -3.048}, 50.800, 0.119, NaN), CurvePt({11.940, 2.934, -3.016}, 51.062, 0.120, NaN), CurvePt({11.683, 2.898, -2.985}, 51.323, 0.121, NaN), CurvePt({11.428, 2.853, -2.954}, 51.582, 0.122, NaN), CurvePt({11.176, 2.801, -2.922}, 51.839, 0.123, NaN), CurvePt({10.927, 2.741, -2.890}, 52.094, 0.124, NaN)  …  CurvePt({5.199, -3.176, -1.790}, 60.764, 0.123, NaN), CurvePt({5.147, -3.428, -1.759}, 61.022, 0.122, NaN), CurvePt({5.103, -3.683, -1.727}, 61.280, 0.121, NaN), CurvePt({5.066, -3.940, -1.696}, 61.541, 0.120, NaN), CurvePt({5.037, -4.201, -1.665}, 61.803, 0.119, NaN), CurvePt({5.017, -4.465, -1.633}, 62.068, 0.118, NaN), CurvePt({5.004, -4.731, -1.602}, 62.334, 0.117, NaN), CurvePt({5.000, -5.000, -1.571}, 62.603, 0.115, NaN), CurvePt({5.000, -5.000, -1.571}, 62.603, 0.000, NaN), CurvePt({5.000, -55.000, -1.571}, 112.603, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])
 RoadSegment{Float64}(5, Lane{Float64}[Lane{Float64}(LaneTag(5, 1), CurvePt{Float64}[CurvePt({8.000, -55.000, 1.571}, 0.000, 0.000, NaN), CurvePt({8.000, -5.000, 1.571}, 50.000, 0.000, NaN), CurvePt({8.002, -4.821, 1.544}, 50.179, -0.153, NaN), CurvePt({8.010, -4.645, 1.517}, 50.355, -0.157, NaN), CurvePt({8.021, -4.471, 1.489}, 50.530, -0.162, NaN), CurvePt({8.038, -4.300, 1.461}, 50.702, -0.166, NaN), CurvePt({8.059, -4.131, 1.432}, 50.872, -0.171, NaN), CurvePt({8.085, -3.965, 1.403}, 51.040, -0.175, NaN), CurvePt({8.115, -3.802, 1.373}, 51.206, -0.180, NaN), CurvePt({8.150, -3.641, 1.343}, 51.370, -0.184, NaN)  …  CurvePt({11.802, -0.115, 0.198}, 56.755, -0.180, NaN), CurvePt({11.965, -0.085, 0.168}, 56.921, -0.175, NaN), CurvePt({12.131, -0.059, 0.139}, 57.089, -0.171, NaN), CurvePt({12.300, -0.038, 0.110}, 57.259, -0.166, NaN), CurvePt({12.471, -0.021, 0.082}, 57.431, -0.162, NaN), CurvePt({12.645, -0.010, 0.054}, 57.605, -0.157, NaN), CurvePt({12.821, -0.002, 0.027}, 57.782, -0.153, NaN), CurvePt({13.000, 0.000, 0.000}, 57.961, -0.148, NaN), CurvePt({13.000, 0.000, 0.000}, 57.961, 0.000, NaN), CurvePt({63.000, 0.000, 0.000}, 107.961, 0.000, NaN)], 3.0, SpeedLimit(-Inf, Inf), LaneBoundary(:unknown, :unknown), LaneBoundary(:unknown, :unknown), LaneConnection{Int64,Float64}[], LaneConnection{Int64,Float64}[])])</code></pre><p>Append left turn coming from below</p><pre><code class="language-julia">curve = gen_straight_curve(convert(VecE2, D+VecE2(0,-50)), convert(VecE2, D), 2)
append_to_curve!(curve, gen_bezier_curve(D, A, 0.9r, 0.9r, 51)[2:end])
append_to_curve!(curve, gen_straight_curve(convert(VecE2, A), convert(VecE2, A+VecE2(-100,0)), 2))
lane = Lane(LaneTag(length(roadway.segments)+1,1), curve)
push!(roadway.segments, RoadSegment(lane.tag.segment, [lane]))

snapshot = render([roadway])</code></pre><p><img src="../intersection.svg" alt="intersection"/></p><p>We can identify each lane thanks to the following user-defined functions. We define a <code>LaneOverlay</code> object that indicate the lane to highlight. One could implement any custom type to display other information on the lane. We then add a new method to the <code>add_renderable!</code> function that execute the specific action (coloring in blue). Look at <code>AutomotiveVisualization.jl</code> for more detail on the function <code>add_renderable!</code>.</p><p>The following animation iterates over the individual lanes of the intersection layout and highlights them:</p><pre><code class="language-julia">struct LaneOverlay
    roadway::Roadway
    lane::Lane
    color::Colorant
end
function AutomotiveVisualization.add_renderable!(rendermodel::RenderModel, overlay::LaneOverlay)
    add_renderable!(rendermodel, overlay.lane, overlay.roadway, color_asphalt=overlay.color)
end


using Reel

animation = roll(fps=1.0, duration=length(roadway.segments)) do t, dt
    i = Int(floor(t/dt)) + 1
    renderables = [
        roadway,
        LaneOverlay(roadway, roadway[LaneTag(i,1)], RGBA(0.0,0.0,1.0,0.5))
    ]
    render(renderables)
end;</code></pre><p><img src="../highlighted_lanes.gif" alt="highlighted lanes"/></p><h2 id="Navigation-in-the-new-road-network-1"><a class="docs-heading-anchor" href="#Navigation-in-the-new-road-network-1">Navigation in the new road network</a><a class="docs-heading-anchor-permalink" href="#Navigation-in-the-new-road-network-1" title="Permalink"></a></h2><p>Let&#39;s populate the intersection</p><pre><code class="language-julia">vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0) # initial state of the vehicle
scene = Scene([Entity(vs0, VehicleDef(), 1)])

snapshot = render([roadway, scene])</code></pre><p><img src="../intersection_populated.svg" alt="populated intersection"/></p><p>We will use lateral and longitudinal acceleration to control a car in the intersection. The first step is to define a corresponding action type that will contain the acceleration inputs.</p><pre><code class="language-julia">struct LaneSpecificAccelLatLon
    a_lat::Float64
    a_lon::Float64
end</code></pre><p>Next, add a method to the propagate function to update the state using our new action type.</p><pre><code class="language-julia">function AutomotiveSimulator.propagate(veh::Entity, action::LaneSpecificAccelLatLon, roadway::Roadway, Δt::Float64)
    lane_tag_orig = veh.state.posF.roadind.tag
    state = propagate(veh, LatLonAccel(action.a_lat, action.a_lon), roadway, Δt)
    roadproj = proj(state.posG, roadway[lane_tag_orig], roadway, move_along_curves=false)
    retval = VehicleState(Frenet(roadproj, roadway), roadway, state.v)
    return retval
end</code></pre><p><strong>Driver Model:</strong></p><p>We define a driver model, which can be seen as a distribution over actions.  # TODO Here we will define the simplest model, which is to repeat the same action.</p><pre><code class="language-julia">struct InterDriver &lt;: DriverModel{LaneSpecificAccelLatLon}
    a::LaneSpecificAccelLatLon
end

AutomotiveSimulator.observe!(model::InterDriver, scene::Scene, roadway::Roadway, egoid::Int64) = model
Base.rand(::AbstractRNG, model::InterDriver) = model.a</code></pre><p><strong>Simulate:</strong></p><p>First associate a model to each driver in the scene using a dictionary. Here we only have one driver identified by its ID: 1. Then everything is ready to run the <code>simulate!</code> function.</p><pre><code class="language-julia">using Reel

timestep = 0.1
nticks = 100

vs0 = VehicleState(B + polar(50.0,-π), roadway, 8.0)
scene = Scene([Entity(vs0, VehicleDef(), 1)])
models = Dict(1 =&gt; InterDriver(LaneSpecificAccelLatLon(0.0,0.0)))
scenes = simulate(scene, roadway, models, nticks, timestep)

animation = roll(fps=1.0/timestep, duration=nticks*timestep) do t, dt
    i = Int(floor(t/dt)) + 1
    renderables = [roadway, scenes[i]]
    render(renderables)
end</code></pre><pre><code class="language-none">&quot;animated_intersection.gif&quot;</code></pre><p><img src="../animated_intersection.gif" alt="animated intersection"/></p><hr/><p><em>This page was generated using <a href="https://github.com/fredrikekre/Literate.jl">Literate.jl</a>.</em></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../stadium/">« Driving in a Stadium</a><a class="docs-footer-nextpage" href="../crosswalk/">Crosswalk »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 10 August 2020 05:28">Monday 10 August 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
